[{invert}]
= Le Langage Go

image::go.jpeg[caption="Golang",width=1024]

== Pourquoi Go dans ce Cours?

* Peu importe les outils, les probl√®mes sous jacents li√© au CI/CD sont les m√™mes
* Faire face √† un nouveau langage est quelque chose de fr√©quent

== Qu'est ce que Go?

* üß± Langage fortement typ√©
* üíª Compil√©
* ¬© Syntaxe proche du C
* ‚òÅÔ∏è Gestion de la m√©moire automatis√©e
* üîÑ Con√ßu pour le traitement concurrent

== Go Propulse Le Cloud!

* Issu de chez Google
* Premi√®re version publique en 2009
* v1.0 en 2012 ... et r√©trocompatible depuis!
* Utilis√© dans de nombreux projets!
** Docker, Kubernetes, Terraform, Prometheus, Grafana...

== üéì Exercice: Un Premier Programme en Go

* Dans le r√©pertoire `workspace` cr√©ez un repertoire `helloworld`
* Dans ce r√©pertoire, cr√©ez un fichier `main.go` et copiez le code ci-dessous.

[source,go]
----
include::../code-samples/go/helloworld.go[]
----

* Compilez votre programme a l'aide de la commande `go build ./main.go`
* Executez le programme g√©n√©r√© `./main`

== ‚úÖ Solution: Un Premier Programme en Go

[source,bash]
----
# Cr√©e un r√©pertoire helloworld
mkdir -p /workspace/helloworld
# Saute dans le r√©pertoire
cd /workspace/helloworld
# Cr√©e un fichier main.go
touch main.go
# Ouvre le fichier main.go dans l'√©diteur
code main.go
# Compile le programme
go build ./main.go
# Ex√©cute le programme.
./main
----

== !

üí° `go run ./main.go` compile et execute le programme directement!

‚ö†Ô∏è  Ne g√©n√®re pas de binaire utilisable.

[source,bash]
----
$ go run ./main.go
Hello ENSG!
----

== Formatage de Code

* Formatage du code automatique, si vous appuyez sur `Ctrl+S`
* Pas de d√©bat tabs vs spaces ü§°, c'est des tabs.

== Anatomie d'un Fichier go (1/2)

[source,go]
----
include::../code-samples/go/helloworld.go[]
----

== Anatomie d'un Fichier go (2/2)

* `func`: Declare une fonction `main`:
** Cette fonction appelle la fonction `Println` du package `fmt`
** En passant la chaine de caract√®res "Hello ENSG!"
* `package`: declare que ce fichier fait partie du package `main`.
* `import`: importe le package `fmt` dans le fichier

== Packages & Imports (1/2)

* Un package est un groupe logique de symboles (variables, constantes, types et fonction)
* Un package est identifi√© par une URL indiquant ou le t√©l√©charger
** üëâ Tous les packages sont uniques!
** Ex: `github.com/jlevesy/prometheus-elector/config`
* Sauf pour la librarie standard, ou il n'y a pas de domaines
** Ex: `net/http`, `os`
* Un package est import√© par un autre package
** Ici notre programme importe le package `fmt`

== Packages & Imports (2/2)

* Un package est repr√©sent√© par un r√©pertoire dans un d√©pot de code
* Tous les fichiers go presents dans un m√™me repertoire doivent declarer le meme package
* *Convention*: Le nom du package d√©clar√© est le m√™me que celui du r√©pertoire content le fichier
** Ex: Les fichiers pr√©sents dans `github.com/jlevesy/prometheus-elector/config` commencent tous par  `package config`

== !

Mais ce n'est pas le cas de notre programme?

== ‚ÑπÔ∏è Le Package Sp√©cial `main`

* Ce package est le `point d'entr√©e` du programme.
* La fonction `main` du package `main` est la premi√®re fonction appell√©e lors de l'ex√©cution d'un programme go.

== Packages et Visibilit√©

* La visibilit√© en dehors du package d'un symbole d√©clar√© dans un package est controll√©e par l'utilisation d'une majuscule ou minuscule en premier caract√®re.
** Une *majuscule* rendra le symbole publique et utilisable en dehors du package.
** Une *minuscule* rendra le symbole priv√© seulement accessible dans le package courant.

[source,go]
----
include::../code-samples/go/examples.go[tags="package_visibility"]
----

== !

Controller la visibilit√© des symboles export√© permet de s'assurer que le package sera bien utilis√©!

C'est l'id√©e *d'encapsulation*, on expose uniquement ce dont l'utilisateur √† besoin.

== Origine des Packages

Votre fichier peut d√©pendre d'un package issu de:

* Votre de projet courant
* La (link:https://pkg.go.dev/std[tr√®s fournie]) librarie standard de Go
* D'une librairie externe

[source,go]
----
include::../code-samples/go/imports.go[tags="import"]
----

== Variables (1/3)

Une variable est une zone m√©moire allou√©e contenant une valeur

[source,go]
----
include::../code-samples/go/examples.go[tags="main_start,variables,main_end"]
----

== Variables (2/3)

Une variable est d√©finie dans un "scope", par d√©faut une fonction. C'est sa dur√©e de vie.

[source,go]
----
include::../code-samples/go/examples.go[tags="var_scopes"]
----

== Variables (3/3)

‚ö†Ô∏è Go est un langage fortement typ√© ‚ö†Ô∏è

[source,go]
----
include::../code-samples/go/examples.go[tags="main_start,variables_bad,main_end"]
----

== !

image::static_types.png[caption="Gymmastics",width=512]

== Constantes

[source,go]
----
include::../code-samples/go/examples.go[tags="consts"]
----

== Types Scalaires

* Numeriques: `int`, `intX`, `uint`, `uintX`, `float32`, `float64`
* Bool√©en: `bool`
* Chaine de caract√®res UTF-8: `string`
* Autres: `byte` (octet), `rune` (caract√®re UTF-8)

== Conversions

[source,go]
----
include::../code-samples/go/examples.go[tags="conversions"]
----

== Controle de Flot

== Controle de Flot: if (1/2)

[source,go]
----
include::../code-samples/go/examples.go[tags="flow_control_if_1"]
----

== Controle de Flot: if (2/2)

[source,go]
----
include::../code-samples/go/examples.go[tags="flow_control_if_2"]
----

== Controle de Flot: switch

[source,go]
----
include::../code-samples/go/examples.go[tags="flow_control_switch"]
----

== Controle de Flot: boucle for

[source,go]
----
include::../code-samples/go/examples.go[tags="flow_control_for"]
----

== Fonctions(1/4)

* Une fonction est un groupement logique d'instructions
* Accepte entre 0 et N arguments
* üéâ Retourne entre 0 et N r√©sultats üéâ

[source,go]
----
include::../code-samples/go/examples.go[tags="func_examples_1"]
----

== Fonctions(2/4)

* Les fonctions peuvent √™tre manipul√©es comme des valeurs!

[source,go]
----
include::../code-samples/go/examples.go[tags="func_examples_2"]
----

== Fonctions(3/4)

* Go permets de "reporter" l'ex√©cution d'une fonction quand une fonction parente se termine
* Pratique pour garantir qu'une resource soit lib√©r√©e quoi qu'il se passe lors de l'ex√©cution de la fonction.
** Similaire aux "destructeurs" en C++

[source,go]
----
include::../code-samples/go/examples.go[tags="func_defer"]
----

== Fonctions(4/4)

* Les arguments de fonctions sont pass√©s par valeur.
* Cela signifie que les valeurs des arguments sont copi√©s lors de l'appel

[source,go]
----
include::../code-samples/go/examples.go[tags="func_pass_by_value"]
----

== Pointeurs (1/3)

* D√©clarer une variable reviens √† indiquer au programme d'allouer une certaine quantit√© de m√©moire (en fonction du type de la variable) √† une adresse en m√©moire
* üéì Go permets de *r√©f√©rencer* cet emplacement memoire en copiant son adresse dans une autre variable avec l'op√©rateur `&`. Autrement dit, on *cr√©e un pointeur*.

[source,go]
----
include::../code-samples/go/examples.go[tags="main_start,pointers_ref,main_end"]
----

== Pointeurs (2/3)

* √Ä l'inverse, on peut aussi acc√©der au contenu d'une variable r√©f√©renc√©e par un pointeur.
* üéì Cela est appel√© *d√©r√©f√©rencer* un pointeur, avec l'op√©rateur `*`.

[source,go]
----
include::../code-samples/go/examples.go[tags="main_start,pointers_deref,main_end"]
----

== Pointeurs (3/3)

* üéì Les types *pointeur sur X* sont des types dit de *r√©f√©rence*.
* üéì La valeur par d√©faut d'un type r√©f√©rence est `nil`.
* Il existe d'autres types r√©f√©rences en go.

[source,go]
----
include::../code-samples/go/examples.go[tags="main_start,pointers_panic,main_end"]
----

== üéì Exercice: Corriger la Fonction

* Corriger la fonction `addGreeting` pour qu'elle affiche correctement `Hello John`
* Sans retourner de valeur.

[source,go]
----
include::../code-samples/go/examples.go[tags="func_pass_by_value"]
----

== ‚úÖ Solution: Corriger la Fonction

[source,go]
----
include::../code-samples/go/examples.go[tags="func_pass_by_reference"]
----

== Gestion d'Erreur (1/2)

* Go traite les erreurs avec des valeurs retour au lieu d'exeptions
* Il est commun qu'une fonction qui puisse √©chouer retourne une valeur et un r√©sultat.
** Il convient alors de v√©rifier l'erreur retourn√©e soit √©gale a nil.
** ...Sinon il faudra la g√©rer!

[source,go]
----
include::../code-samples/go/examples.go[tags="error_example"]
----

== Gestion d'Erreur (2/2)

* Certaines instructions peuvent mettre le programme dans un √©tat ou il ne peut plus s'ex√©cuter.
** Par exemple, acc√©der √† un pointeur `nil`
* Dans ce cas la, l'ex√©cution de la fonction s'arr√™te et on parle de `panic`

== Collections

== Collections: Arrays

* Un tableau de taille fixe de N elements.
* ‚ö†Ô∏è  La taille du tableau fait partie de son type
** *Limite*: ne peut pas √™tre chang√©e une fois le tableau instanci√©.

[source,go]
----
include::../code-samples/go/examples.go[tags="arrays"]
----

üëâ On √©vite en g√©n√©ral de les utiliser directement, sauf bonne raison.

== Collections: Slices (1/5)

Une `slice` est une r√©f√©rence sur un sous ensemble d'entr√©es dans un tableau

[source,go]
----
include::../code-samples/go/examples.go[tags="slices"]
----

== Collections: Slices (2/5)

* On peut initialiser directement une slice sans passer par un tableau.
* On peut aussi initialiser une slice avec l'operateur `make`

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_literals"]
----

== Collections: Slices (3/5)

Une `slice` poss√®de deux caract√©ristiques importantes:

* Sa taille: le nombre d'√©l√©ments pr√©sents dans la slice
** On y acc√®de a l'aide de la fonction `len`
* Sa capacit√©: la taille totale du tableau r√©f√©renc√©
** On y acc√®de a l'aide de la fonction `cap`

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_len_cap"]
----

== Collections: Slices (4/5)

* On peut concat√©ner des objets √† une slice avec l'operateur `append`
* ‚ö†Ô∏è  Cela n'ajoute pas n√©cessairement un entr√©e a la slice pass√©e en parametre.
** Dans le cas ou le tableau sous jacent est plein (len == cap), `append` va r√©allouer un tableau et copier toutes les ent√©es dans ce nouveau tableau.
** üëâ En cons√©quence: il faut *TOUJOURS* assigner la valeur retourn√©e par `append`

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_append"]
----

== Collections: Slices (5/5)

* Le type *slice de X*, comme le type *pointeur sur X*, est un type r√©f√©rence.
* Sa valeur par d√©faut est `nil`
* Acc√©der √† une slice nil provoque un arr√™t de l'ex√©cution
* En revanche: `append` et `len` savent g√©rer une nil slice.

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_nil"]
----

== Parcourir une slice ou un tableau

* Go fournit la fonction `range` qui permet de parcourir une collection.
* `range` accepte une collection, et retourne deux valeurs:
** L'index courant dans la collection
** La valeur de la collection a l'index

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_range"]
----

== üéì Exercice: Convertir une collection d'entiers en une collection de strings

* Ecrire une fonction `toStringSlice` qui convertit slice d'entiers en une slice de strings.
** üïµÔ∏è: Il faut utiliser la fonction *strconv.Itoa* link:https://pkg.go.dev/strconv#Itoa[doc]

== ‚úÖ Solution: Convertir une collection d'entiers en une collection de strings

[source,go]
----
include::../code-samples/go/examples.go[tags="slices_int_to_string"]
----

== Collections: maps (1/3)

* Tableau associatif cl√©-valeur
* Initialis√©e de fa√ßon litt√©rale, ou avec `make`
* On r√©cup√®re sa taille avec `len`
* On supprime une cl√© avec `delete`
* Type r√©f√©rence, comme les pointeurs out les slices
** Une map peut √™tre nil, `len` retournera 0.

== Collections: maps (2/3)

Exemple d'√©criture

[source,go]
----
include::../code-samples/go/examples.go[tags="maps"]
----

== Collections: maps (3/3)

Exemple de lecture

[source,go]
----
include::../code-samples/go/examples.go[tags="maps_reads"]
----

== Parcourir une map

* `range` supporte aussi les maps dans une boucle for
* Assigne la cl√© et la valeur courante
* ‚ö†Ô∏è L'ordre de parcours n'est pas d√©terministe! Il ne faut pas en d√©pendre!

[source,go]
----
include::../code-samples/go/examples.go[tags="maps_range"]
----

== üéì Exercice: Comptez les occurences de mots dans une chaine de caract√®re

* Ecrivez une fonction `WordCount` en go qui accepte une chaine de caract√®re et qui retourne le nombre d'occurences de chacun des mots contenu dans la chaine.
** *Indice*: La signature de votre fonction devrait resembler a `func WordCount(str string) map[string]int`.
*** La valeur de retour mappe le mot vers le nombre de fois qu'il est apparu.
** *Indice*: `strings.Fields` link:https://pkg.go.dev/strings#Fields[(doc)] s√©pare les mots d'une chaine de caract√®re et retourne une string.

== ‚úÖ Solution: Comptez les occurences de mots dans une chaine de caract√®re

[source,go]
----
include::../code-samples/go/examples.go[tags="word_count"]
----

== Structures (1/3)

* Type d√©clar√© repr√©sentant une collection fixe d'attributs (aussi appel√©s membres)
* Les attributs commen√ßant par une lettre majuscules sont accessibles en dehors du package. Ceux qui commencent par une lettre minuscule ne le sont pas.

[source,go]
----
include::../code-samples/go/examples.go[tags="structs"]
----

== Structures (2/3)

* La valeur par d√©faut d'une structure est √©gale a l'ensemble des valeurs par d√©faut de ses membres.

[source,go]
----
include::../code-samples/go/examples.go[tags="struct_defaults"]
----

== Structures (3/3)

* Toute structure doit instanci√©e doit √™tre dans un √©tat utilisable.
* Si les valeurs par d√©faut ne suffisent pas, on peut fournir une fonction d'initialisation.
** Similaire aux "constructeurs" dans d'autres langages.


[source,go]
----
include::../code-samples/go/examples.go[tags="struct_initialization"]
----

== Annotations de Structures

* Go permets d'annoter les membres d'une structure
* Utilisation diverses
** Ex: indiquer le champ d'un object JSON a li√© √† l'attribut.

[source,go]
----
include::../code-samples/go/examples.go[tags="struct_annot"]
----

== Definir des Types

* Nous avons utilis√© le mot clef `type` pour d√©finir un nouveau type de structure.
* Mais `type` peut √™tre appliqu√© √° des tas d'autre choses.

[source,go]
----
include::../code-samples/go/examples.go[tags="types"]
----

== Types et M√©thodes (1/2)

* Il est possible d'attacher des m√©thodes aux types que l'on d√©finit

[source,go]
----
include::../code-samples/go/examples.go[tags="methods_1"]
----

== Types et M√©thodes (2/2)

* Une structure avec des m√©thodes est l'√©quivalent d'une classe dans d'autres langages.
* Le "Receveur" est √©quivalent a *this* en C++ ou Java.

[source,go]
----
include::../code-samples/go/examples.go[tags="methods_2"]
----

== Receveurs: Pointeurs ou Valeurs?

* On peut attacher une m√©thode sur une valeur du type, ou sur un pointeur.
* L'op√©rateur `.` (acc√©s) r√©f√©rence et d√©r√©f√©rence les pointeurs implicitement.
* Quelques r√®gles:
** Sur les types scalaires (int, string etc...) on pr√©f√®rera les valeurs, la copie ne coute rien.
** Sur les collections et fonctions, on garde les valeurs, ce sont des types r√©f√©rences.
** Sur les structs, on pr√©f√®re attacher au pointeurs car cela √©vite une copie parfois lourde.

== Types Abstraits: Interfaces (1/3)

* Une interface d√©crit un jeu de m√©thodes.
* Une variable du type de l'interface peut recevoir n'importe quel type qui impl√©mente les m√©thodes de l'interface.
* Le comportement d'un appel de m√©thode est celui du type concret cach√© derri√®re l'interface. C'est ce qu'on appelle le *Polymorphisme*.

== Types Abstraits: Interfaces (2/3)

[source,go]
----
include::../code-samples/go/examples.go[tags="polymorphism"]
----

== Types Abstraits: Interfaces (3/4)

* Une interface est un type r√©f√©rence vers un autre type, sa valeur par d√©faut est `nil`.
* Les interfaces sont implicites:
** Du moment que le type de la valeur satisfait toutes les methodes de l'interface, alors il est consid√©r√© comme impl√©mentant l'interface.
** Pas de mot cl√© `implements` comme en Java

== Types Abstraits: Interfaces (4/4)

* Pourquoi s'emb√™ter √† faire des interfaces?
** Fournir du code g√©n√©rique
** D√©coupler, cacher la complexit√©
*** Exemple: Cacher une d√©pendance √† une base de donn√©es derri√®re une interface

[source,go]
----
include::../code-samples/go/examples.go[tags="io_example"]
----

== Interfaces Importantes en Go

* package `io`:
** link:https://pkg.go.dev/io#Reader[io.Reader], link:https://pkg.go.dev/io#Writer[io.Writer], link:https://pkg.go.dev/io#Closer[io.Closer]
* package `http`:
** link:https://pkg.go.dev/net/http#Handler[http.Handler] permet de g√©rer et r√©pondre √† une requ√™te HTTP.
* Le type `error`

[source,go]
----
include::../code-samples/go/examples.go[tags="error_type"]
----

== Nommage de variables

* *Convention*: La longueur du nom d'une variable est proportionnelle √† sa dur√©e de vie.
* Certaines exceptions:
** `err` pour une valeur d'erreur
** `ctx` toute instance d'un a `context.Context`
** Receveurs de m√©thodes (ie `*Store` =>  `st`)
** Et d'autres...

== Quelques Exemples

* Decoder du JSON

[source,go]
----
include::../code-samples/go/examples.go[tags="decode_json"]
----

== Quelques Exemples

* Lire l'int√©gralit√© d'un Buffer

[source,go]
----
include::../code-samples/go/examples.go[tags="read_buffer"]
----

== Quelques Exemples

* Faire une requ√™te HTTP

[source,go]
----
include::../code-samples/go/examples.go[tags="http_request"]
----

== üéì Exercice: Donnez le Climat de Tatooine

On vous demande le programme go suivant:

* Fait une requ√™te a swapi.dev pour r√©cup√©rer les informations de la planete Tatooine
** L'URL a appeler est link:https://swapi.dev/api/planets/1/[https://swapi.dev/api/planets/1/]
* Si la requ√™te est r√©ussie alors on lit l'int√©gralit√© du corps de la r√©ponse
* Et on d√©serialise la r√©ponse dans un object pour acc√©der au `climat`

* **Bonus**: Une fois fini, essayez de nous donner le diametre de l'√©toile noire aussi.

== ‚úÖ Solution: Le Climat de Tatooine

[source,go]
----
include::../code-samples/go/examples.go[tags="tatooine_climate"]
----

== R√©ferences

* Vid√©os
** https://www.youtube.com/watch?v=xi8732QO33Y
** https://www.youtube.com/c/JustForFunc

* Guides complets
** https://go.dev/tour/
** https://gobyexample.com/

* Pour aller plus loin
** https://go.dev/doc/effective_go
** https://go.dev/doc/
** https://go-proverbs.github.io/
