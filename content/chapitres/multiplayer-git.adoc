[{invert}]
= Git √† plusieurs

== Limites de travailler seul

* Capacit√© finie de travail
* Victime de propres biais
* On ne sait pas tout

== !

image:solo.gif[width="500"]

== Travailler en √©quipe ? Une si bonne id√©e ?

* ... Mais il faut communiquer ?
* ... Mais tout le monde n'a pas les m√™mes comp√©tences ?
* ... Mais tout le monde y code pas pareil ?

== !

Collaborer c'est pas √©vident, mais il existe des outils et des m√©thodes pour vous aider.

[.small]
Cela reste des outils, √ßa ne r√©souds pas tout non plus.

== Git multijoueur

* Git permet de collaborer assez ais√©ment
* Chaque d√©veloppeur cr√©e et publie des commits...
* ... et rapatrie ceux de de ses camarades !
* C'est un outil tr√®s flexible... chacun peut faire ce qu'il lui semble bon !

== ... et (souvent) √ßa finit comme √ßa !

image:bloing.jpeg[]

== Un Example de Git Flow

(Attachez vous aux id√©es g√©n√©rales... les d√©tails varient d'un projet √† l'autre!)

== Gestion des branches

* Les "versions" du logiciel sont maintenues sur des branches principales (main, staging)

* Ces branches refl√®tent l'√©tat du logiciel
** **main**: version actuelle en production
** **staging**: prochaine version

== !

image:gitmulti1.svg[]

== Gestion des branches

* Chaque groupe de travail (d√©veloppeur, bin√¥me...)
** Cr√©e une branche de travail √† partir de la branche staging
** Une branche de travail correspond √† *une chose √† la fois*
** Pousse des commits dessus qui impl√©mentent le changement

== !

image:gitmulti2.svg[]

== !

image:gitmulti3.svg[width=500]

Quand le travail est fini, la branche de travail est "merg√©e" dans staging

== !

image:gitmulti4.svg[width=500]

== Gestion des remotes

O√π vivent ces branches ?

== Plusieurs mod√®les possibles

* Un remote pour les gouverner tous !
* Chacun son propre remote (et les commits seront bien gard√©s)
* ... whatever floats your boat!

== Un remote pour les gouverner tous

Tous les d√©veloppeurs envoient leur commits et branches sur le m√™me remote

* Simple a g√©rer ...
* ... mais n√©cessite que tous les contributeurs aient acc√®s au d√©p√¥t
** Adapt√© a l'entreprise, peu adapt√© au monde de l'open source

== !

image:remotemulti1.svg[]

== Chacun son propre remote

* La motivation: le contr√¥le d'acc√®s
** Tout le monde peut lire le d√©p√¥t principal. Personne ne peut √©crire dessus.
** Tout le monde peut dupliquer le d√©p√¥t public et √©crire sur sa copie.
** Toute modification du d√©p√¥t principal passe par une proc√©dure de revue.
** Si la revue est valid√©e, alors la branche est "merg√©e" dans la branche cible

* C'est le mod√®le pouss√© par GitHub !

== !

image:remotemulti2.svg[width=800]

== Forks ! Forks everywhere !

Dans la terminologie GitHub:

* Un fork est un remote copi√© d'un d√©p√¥t principal
** C'est la o√π les contributeurs poussent leur branche de travail.
* Les branches de version (main, staging...) vivent sur le d√©p√¥t principal
* La proc√©dure de ramener un changement d'un fork √† un d√©p√¥t principal s'appelle la Pull Request (PR)

== üéì Exercice : Cr√©ez un fork

* Nous allons vous faire forker vos d√©p√¥ts respectifs
* Trouvez vous un bin√¥me dans le groupe.
* Rendez vous link:https://docs.google.com/spreadsheets/d/1RyRn930gQpTKGoU_hpuZ70fAi2SpTm36oDxc44rGZwE/edit?usp=sharing[sur cette page,window="_blank"] pour inscrire votre bin√¥me.
* Depuis la page du d√©p√¥t de votre bin√¥me, cliquez en haut √† droite sur le bouton **Fork**.

image:fork.png[]

[{invert}]
== !

A vous de jouer: Corrigez la fonctionnalit√© "suppression d'un vehicule" dans projet de votre bin√¥me

== üéì Exercice : Contribuez au projet de votre bin√¥me (1/4)

Premi√®re √©tape: on clone le fork dans son environnement de d√©veloppement

[source,bash]
--
cd /workspace/

# Clonez votre fork
git clone <url_de_votre_fork>

# Cr√©ez votre feature branch
git switch --create fix-delete
# √âquivalent de git checkout -b <...>
--

== Minute Go: L'interface http.Handler

[source,go]
----
type Handler interface {
	ServeHTTP(rw ResponseWriter, r *Request)
}
----

* Interface de la librairie standard qui normalise tous les types pouvant "g√©rer une requ√™te HTTP"
* Elle accepte deux arguments
** `rw`: Le "response writer", qui permet d'√©crire le code de status, les headers et le corps de la r√©ponse
** `r`: La requ√™te √† traiter
* Nos impl√©mentations de `http.Handler` se trouvent dans le package `vehicle`.

*Pouvez vous identifier le code probl√©matique?*

== üéì Exercice : Contribuez au projet de votre bin√¥me (2/4)

* Extraire l'identifiant (la valeur `id`) du path en utilisant la m√©thode link:https://pkg.go.dev/net/http#Request.PathValue[PathValue].
* Parser la valeur obtenue en `int64` en utilisant link:https://pkg.go.dev/strconv#ParseInt[strconv.ParseInt]
* Appeler la methode `Delete` du `VehicleStore` en passant l'identifiant et le "contexte" r√©cup√©r√© en appelant `r.Context()`
* Enfin il faut faire une r√©ponse:
** Si la suppression est r√©ussie, r√©pondre un status code 204 en appelant `rw.WriteHeader(http.StatusNoContent)`,
** Si le v√©hicle indiqu√© n'existe pas, r√©pondre 404.
* Il convient de g√©rer les erreurs correctement, vous pouvez vous inspirer des hautres handlers d√©fini dans le package!

== üéì Exercice : Contribuez au projet de votre bin√¥me (3/4)

Une fois que vous √™tes satisfaits de votre changement il vous faut maintenant cr√©er un commit et pousser votre nouvelle branche sur votre fork.

== üéì Exercice : Contribuez au projet de votre bin√¥me (4/4)

Derni√®re √©tape: ouvrir une pull request!

* Rendez vous sur la page de votre projet
* S√©lectionnez votre branche dans le menu d√©roulant "branches"  en haut a gauche.
* Cliquez ensuite sur le bouton ouvrir une pull request
* Remplissez le contenu de votre PR (titre, description, labels) et validez.

image:pr.png[width=500]

== La proc√©dure de Pull Request

*Objectif* : Valider les changements d'un contributeur

* Technique : est-ce que √ßa marche ? est-ce maintenable ?
* Fonctionnel : est-ce que le code fait ce que l'on veux ?
* Humain : Propager la connaissance par la revue de code.
* M√©thode : Tracer les changements.

== Revue de code ?

* Validation par un ou plusieurs pairs (technique et non technique) des changements
* Relecture depuis github (ou depuis le poste du d√©veloppeur)
* Chaque relecteur √©met des commentaires // suggestions de changement
* Quand un relecteur est satisfait d'un changement, il l'approuve

== !

* La revue de code est un **exercice difficile** et **potentiellement frustrant** pour les deux parties.
** Comme sur Twitter, on est bien √† l'abri derri√®re son √©cran
* En tant que contributeur, **soyez respectueux** de vos relecteurs : votre changement peut √™tre refus√© et c'est quelque chose de normal.
* En tant que relecteur, **soyez respectueux** du travail effectu√©, m√™me si celui ci comporte des erreurs ou ne correspond pas √† vos attentes.

üí° Astuce: link:https://github.com/franckverrot/clamav-client/pull/12#discussion_r526222319[Proposez des solutions,window="_blank"] plut√¥t que simplement pointer les probl√®mes.

== üéì Exercice : Relisez votre PR re√ßue !

* Vous devriez avoir re√ßu une PR de votre bin√¥me
* Relisez le changement de la PR
* Effectuez quelques commentaires (bonus: utilisez la suggestion de changements), si c'est n√©cessaire
* Si elle vous convient, approuvez la!
* En revanche ne la "mergez" pas, car il manque quelque chose...

== Validation automatis√©e

**Objectif**: Valider que le changement n'introduit pas de r√©gressions dans le projet

* A chaque fois qu'un nouveau commit est cr√©√© dans une PR, une succession de validations ("checks") sont d√©clench√©s par GitHub
* Effectue des v√©rifications automatis√©es sur un commit de merge entre votre branche cible et la branche de PR

== Quelques exemples

* Analyse syntaxique du code (lint), pour d√©tecter les erreurs potentielles ou les violations du guide de style
* Compilation du projet
* Execution des tests automatis√©s du projet
* D√©ploiement du projet dans un environnement de test...

Ces "checks" peuvent √™tres ex√©cut√©s par votre moteur de CI ou des outils externes.

== üéì Exercice : D√©clencher un Workflow de CI sur une PR

* Votre PR n'a pas d√©clench√© le workflow de CI de votre bin√¥me ü§î
* Il faut changer la configuration de votre workflow pour qu'il se d√©clenche aussi sur une PR
* Vous pouvez changer la configuration du workflow directement dans votre PR
* La link:https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows[documentation,window="_blank"] se trouve par ici

‚ö†Ô∏è  Ne mergez toujours pas votre PR ‚ö†Ô∏è

== ‚úÖ Exercice : D√©clencher un Workflow de CI sur une PR

[source,yaml]
----
include::../code-samples/gh-actions/vehicle-server.yml[tags="!*;pr"]
----

== !

*R√®gle d'or*: Si le CI est rouge, on ne merge pas la pull request !

== üéØ Checkpoint

Nous avons vu:

* Un exemple de mod√®le de gestion de branches git
* Plusieurs mod√®les de gestions de remotes
* Ce qu'est un "fork" sur GitHub
* Le processus pour effectuer une contribution en utilisant un projet fork√©!

‚û°Ô∏è Nous allons maintenant am√©liorer notre CI en ajoutant l'ex√©cution des tests!

