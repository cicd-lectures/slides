[{invert}]
= Git √† plusieurs

== Limites de travailler seul

* Capacit√© finie de travail
* Victime de propres biais
* On ne sait pas tout

== !

image:solo.gif[width="500"]

== Travailler en √©quipe ? Une si bonne id√©e ?

* ... Mais il faut communiquer ?
* ... Mais tout le monde n'a pas les m√™mes comp√©tences ?
* ... Mais tout le monde y code pas pareil ?

== !

Collaborer c'est pas √©vident, mais il existe des outils et des methodes pour vous aider.

[.small]
Cela reste des outils, √ßa ne r√©soud pas tout non plus.

== Git multijoueur

* Git permet de collaborer assez ais√©ment
* Chaque d√©veloppeur cr√©e et publie des commits...
* ... et rapatrie ceux de de ses camarades !
* C'est un outil tr√®s flexible... chacun peut faire ce qu'il lui semble bon !

== ... et (souvent) √ßa finit comme √ßa !

image:bloing.jpeg[]

== Un Example de Git Flow

(Attachez vous aux id√©es g√©n√©rales... les d√©tails varient d'un projet √† l'autre!)

== Gestion des branches

* Les "versions" du logiciel sont maintenues sur des branches principales (main, staging)

* Ces branches refl√™tent l'√©tat du logiciel
** **main**: version actuelle en production
** **staging**: prochaine version

== !

image:gitmulti1.svg[]

== Gestion des branches

* Chaque groupe de travail (d√©veloppeur, bin√¥me...)
** Cr√©e une branche de travail √† partir de la branche staging
** Une branche de travail correspond √† *une chose √† la fois*
** Pousse des commits dessus qui impl√©mentent le changement

== !

image:gitmulti2.svg[]

== !

image:gitmulti3.svg[]

Quand le travail est fini, la branche de travail est merg√©e dans staging

== !

image:gitmulti4.svg[]

== Gestion des remotes

O√π vivent ces branches ?

== Plusieurs mod√®les possibles

* Un remote pour les gouverner tous !
* Chacun son propre remote (et les commits seront bien gard√©s)
* ... whatever floats your boat!

== Un remote pour les gouverner tous

Tous les d√©veloppeurs envoient leur commits et branches sur le m√™me remote

* Simple a g√©rer ...
* ... mais n√©cessite que tous les contributeurs aient acc√®s au d√©pot
** Adapt√© a l'entreprise, peu adapt√© au monde de l'open source

== !

image:remotemulti1.svg[]

== Chacun son propre remote

* La motivation: le contr√¥le d'acc√®s
** Tout le monde peut lire le d√©pot principal. Personne ne peut √©crire desuss.
** Tout le monde peut dupliquer le d√©pot public et √©crire sur sa copie.
** Toute modification du d√©pot principal passe par une proc√©dure de revue.
** Si la revue est valid√©e, alors la branche est "merg√©e" dans la branche cible

* C'est le mod√®le pouss√© par GitHub !

== !

image:remotemulti2.svg[]

== Forks ! Forks everywhere !

Dans la terminologie GitHub:

* Un fork est un remote copi√© d'un d√©pot principal
** C'est la o√π les contributeurs poussent leur branche de travail.
* Les branches de version (main, staging...) vivent sur le d√©pot principal
* La proc√©dure de ramener un changement d'un == Limites de bosser seul

== Exercice: Cr√©ez un fork

* Nous allons vous faire forker vos d√©pots respectifs
* Trouvez vous un bin√¥me dans le groupe.
* Rendez vous link:https://docs.google.com/spreadsheets/d/1cVVdhvDv5ZCG13rXQOlzE62Y7SLsTtpDRprsssjZBhI/edit?usp=sharing[sur cette page,window="_blank"] pour enregistrer votre bin√¥me, et indiquez les liens de vos d√©p√¥ts respectifs.
* Depuis la page du d√©pot de votre bin√¥me, cliquez en haut √† droite sur le bouton **Fork**.

image:fork.png[]

== La proc√©dure de Pull Request

*Objectif* : Valider les changements d'un contributeur

* Technique : est-ce que √ßa marche ? est-ce maintenable ?
* Fonctionnel : est-ce que le code fait ce que l'on veux ?
* Humain : Propager la connaissance par la revue de code.
* M√©thode : Tracer les changements.

== Anatomie d'une Pull Request sur GitHub

* **Branche source**: La branche portant le changement
* **Branche cible**: La branche dans lequel le changement va √™tre merg√©.
* **Titre**: d√©crit de fa√ßon concise le changement apport√©
* **Description**: d√©crit de fa√ßon d√©taill√©e le changement. Doit donner toutes les "cl√©s de lecture" de la PR √† un relecteur
* **Labels**: meta informations permettant de suivre le type de la PR (bugfix, feature?)
* **Historique de commit**: Lors d'une pull request, une attention particuli√®re doit √™tre port√©e aux commits (bien nomm√©s, atomiques), c'est un outil aidant √† la relecture!

[{invert}]
== !

A vous de jouer: Ajoutez la fonctionalit√© "supression d'un menu" au projet de votre bin√¥me

== Exercice: Contribuez au projet de votre bin√¥me (1/5)

Premi√®re √©tape: on clone le fork dans son environement de d√©veloppement

[source,bash]
--
cd /workspace/

# Clonez votre fork
git clone <url_de_votre_fork>

# Cr√©ez votre feature branch
git checkout -b implement-delete
--

== Exercice: Contribuez au projet de votre bin√¥me (2/5)

Maintenant voici la liste des choses √† faire:

* Rajouter le `MenuRepository` comme d√©pendance du MenuController
* Impl√©menter une nouvelle methode `deleteMenu`
** G√®re les requ√™tes `DELETE /menus/{id}`
** Appele la methode `deleteById` du `menuRepository`
** R√©ponds 200 si la suppression est r√©ussie
* Bonus si vous arrivez √† faire en sorte que le serveur r√©ponde 404 si un menu √† supprimer n'existe pas.

Voici un link:https://spring.io/guides/tutorials/rest/[petit article bien utile] pour vous aider!

== Exercice: Contribuez au projet de votre bin√¥me (3/5)

Pour tester votre changement

[source, bash]
--
# D'abord on cr√©e un menu
curl -H "Content-Type: application/json" --data-raw '{"name": "Menu sp√©cial du chef", "dishes": [{"name": "Bananes aux fraises"},{"name": "Bananes flamb√©es"}]}' localhost:8080/menus

# Puis on le supprime
curl -XDELETE localhost:8080/menus/4

# Et on v√©rifie que le menu est bien supprim√©
curl localhost:8080/menus
--

== Exercice: Contribuez au projet de votre bin√¥me (4/5)

Une fois que vous √™tes satisfaits de votre changmement il vous faut maintenant cr√©er un commit et pousser votre nouvelle branche sur votre fork.

== Exercice: Contribuez au projet de votre bin√¥me (5/5)

* Rendez vous sur la page de votre projet
* S√©lectionnez votre branche dans le menu d√©roulant "branches"  en haut a gauche.
* Cliquez ensuite sur le bouton ouvrir une pull request
* Remplissez le contenu de votre PR (titre, description, labels) et validez.

image:pr.png[]

== Revue de code ?

* Validation par un ou plusieur pairs (technique et non technique) des changements
* Relecture depuis github (ou depuis le poste du developpeur)
* Chaque relecteur emet des commentaires // suggestions de changement
* Quand un relecteur est satisfait d'un changement, il l'approuve

== !

* La revue de code est un **exercice difficile** et **potentiellement frustrant** pour les deux parties.
** Comme sur Twitter, on est bien √† l'abri derrir√®re son √©cran ;=)
* En tant que contributeur, **soyez respectueux** de vos relecteurs : votre changement peut √™tre refus√© et c'est quelque chose de normal.
* En tant que relecteur, **soyez respectueux** du travail effectu√©, m√™me si celui ci comporte des erreurs ou ne correspond pas √† vos attentes.

üí° Astuce: link:https://github.com/franckverrot/clamav-client/pull/12#discussion_r526222319[Proposez des solutions] plut√¥t que simplement pointer les probl√®mes.

== Exercice: Relisez votre PR re√ßue !

* Vous devriez avoir re√ßu une PR de votre bin√¥me :-)
* Relisez le changement de la PR
* Effectuez quelques commentaires (bonus: utilisez la suggestion de changements), si c'est necessaire
* Si elle vous convient, approuvez la!
* En revanche ne la mergez pas, car il manque quelque chose...

== Validation automatis√©e

**Objectif**: Valider que le changement n'introduit pas de r√©gressions dans le projet

* A chaque fois qu'un nouveau commit est cr√©√© dans une PR, une succession de validations ("checks") sont d√©clench√©s par GitHub
* Effectue des v√©rifications automatis√©es sur un commit de merge entre votre branche cible et la branche de PR

== Quelques exemples

* Analyse syntaxique du code (lint), pour d√©tecter les erreurs potentielles ou les violations du guide de style
* Compilation du projet
* Execution des tests automatis√©s du projet
* D√©ploiement du projet dans un environnement de test...

Ces "checks" peuvent √™tres execut√©s par votre moteur de CI ou des outils externes.

== Exercice: D√©clencher un Workflow de CI sur une PR

* Votre PR n'a pas d√©clench√© le workflow de CI de votre bin√¥me ü§î
* Il faut changer la spec de votre workflow pour qu'il se d√©clenche aussi sur une PR
* Vous pouvez changer la spec du workflow directement dans votre PR
* La link:https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflow[documentation] se trouve par ici

== !

*R√®gle d'or*: Si le CI est rouge, on ne merge pas la pull request !

[.small]
M√™me si le linter il√©con, m√™me si on a la flemme et s√©panou qui avons cass√© le CI.
