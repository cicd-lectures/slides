[{invert}]
= Docker

image::docker-logo-monochromatic.png[width=200]

Remise Ã  niveau / Rappels

== ğŸ¤” Quel est le problÃ¨me ?

image::matrixfromhell.jpg[]

ProblÃ¨me de temps **exponentiel**

== DÃ©jÃ  vu ?

L'IT n'est pas la seule industrie Ã  rÃ©soudre des problÃ¨mes...

image::also-a-matrix-from-hell.png[]

== Solution: Le conteneur intermodal

"Separation of Concerns"

image::blue-shipping-container.png[]

== Comment Ã§a marche ?

"Virtualisation **LÃ©gÃ¨re**"

image::container_vs_vm.jpg[]

== Conteneur != VM

"Separation of concerns": 1 "tÃ¢che" par conteneur

image::vm-and-container.png[]

==  VMs && Conteneurs

Non exclusifs mutuellement

image::cont-vm-not-excl.png[]

== ğŸ“ Exercice : oÃ¹ est mon conteneur ?

* Retournez dans Gitpod
* Dans un terminal, exÃ©cutez les commandes suivantes :

[source,bash]
----
# Affichez la liste de tous les conteneurs en fonctionnement (aucun)
docker container ls

# ExÃ©cutez un conteneur
docker container run hello-world # Equivalent de l'ancienne commande 'docker run'


docker container ls
docker container ls --all
# Quelles diffÃ©rences ?
----

== ğŸ©» Anatomie

* Un service "Docker Engine" tourne en tÃ¢che de fond et publie une API REST
* La commande `docker run ...` a envoyÃ© une requÃªte `POST` au service
* Le service a tÃ©lÃ©charge une **Image** Docker depuis le registre **DockerHub**,
* Puis a exÃ©cutÃ© un **conteneur** basÃ© sur cette image

== âœ… Solution : OÃ¹ est mon conteneur ?

Le conteneur est toujours prÃ©sent dans le "Docker Engine" mÃªme en Ã©tant arrÃªtÃ©

[source]
----
CONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES
109a9cdd3ec8   hello-world   "/hello"   33 seconds ago   Exited (0) 17 seconds ago             festive_faraday
----

* Un conteneur == une commande "conteneurisÃ©e"
** cf. colonne "*COMMAND*"

* Quand la commande s'arrÃªte : le conteneur s'arrÃªte
** cf. code de sortie dans la colonne "*STATUS*"

== ğŸ“ Exercice : Cycle de vie d'un conteneur en tÃ¢che de fond

* Lancez un nouveau conteneur :
** NommÃ© `webserver-1`,
** basÃ© sur l'image `nginx`,
** En tÃ¢che de fond

[.small]
ğŸ’¡ `docker container run --help` ou https://docs.docker.com/engine/reference/commandline/container_run/[Documentation en ligne,window="_blank"]

* Affichez les "logs" du conteneur (==traces d'exÃ©cution Ã©crites sur le stdout + stderr de la commande conteneurisÃ©e)
** ğŸ’¡ `docker container logs  --help` ou https://docs.docker.com/engine/reference/commandline/container_logs/[Documentation en ligne,window="_blank"]

* Comparez les versions de Linux de Gitpod et du conteneur
** Regardez le contenu du fichier `/etc/os-release`
** ğŸ’¡ `docker container exec`

== âœ… Solution : Cycle de vie d'un conteneur en tÃ¢che de fond

[source,bash]
----
docker container run --detach --name=webserver-1 nginx
# <ID du conteneur>

docker container ls

docker container logs webserver-1

cat /etc/os-release
# ... Ubuntu ...
docker container exec webserver-1 cat /etc/os-release
# ... Debian ...
----

== ğŸ¤” Comment accÃ©der au serveur web en tÃ¢che de fond ?

[source,bash]
----
$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
ee5b70fa72c3   nginx     "/docker-entrypoint.â€¦"   3 seconds ago   Up 2 seconds   80/tcp    webserver-1
----

* âœ… Super, le port 80 (TCP) est annoncÃ© (on parle d'"exposÃ©")...
* âŒ ... mais c'est sur une adresse IP privÃ©e
** `docker container inspect --format='{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' webserver-1`

== ğŸ“ Exercice : AccÃ©der au serveur web via un port publiÃ©

* *But :* CrÃ©ez un nouveau conteneur `webserver-public` accessible publiquement

* Utilisez le port `8080` publique
* ğŸ’¡ Flag `--publish` pour `docker container run`
* ğŸ’¡ GitPod va vous proposer un popup : choisissez "Open Browser"

== âœ… Solution : AccÃ©der au serveur web via un port publiÃ©

[source,bash]
----
docker container run --detach --name=webserver-public --publish 8080:80 nginx
1c5020a818887b1eb4b14b7e75f490db97fac4172c96cc918df63c8c2a0fbaff

curl http://localhost:8080
# ...
----

== ğŸ¤” D'oÃ¹ viennent "hello-world" et "nginx" ?

* Docker Hub (https://hub.docker.com[window="_blank"]) : C'est le registre d'images "par dÃ©faut"
** Exemple : Image officielle de https://hub.docker.com/_/nginx["nginx"]

* ğŸ“ Cherchez l'image `hello-world` pour en voir la page de documentation
** ğŸ’¡ pas besoin de crÃ©er de compte pour Ã§a

* Il existe d'autre "registres" en fonction des besoins (GitHub GHCR, Google GCR, etc.)

== ğŸ¤” Que contient "hello-world" ?

* C'est une "image" de conteneur, c'est Ã  dire un modÃ¨le (template)
reprÃ©sentant une application auto-suffisante.
** On peut voir Ã§a comme un "paquetage" autonome

* C'est un systÃ¨me de fichier complet:
** Il y a au moins une racine `/`
** Ne contient que ce qui est censÃ© Ãªtre nÃ©cessaire (dÃ©pendances, librairies, binaires, etc.)

== ğŸ¤” Pourquoi des images ?

* Un *conteneur* est toujours exÃ©cutÃ© depuis une *image*.
* Une *image de conteneur* (ou "Image Docker") est un  modÃ¨le ("template") d'application auto-suffisant.

=> Permet de fournir un livrable portable (ou presque).

== !

ğŸ¤” Application Auto-Suffisante ?

image::docker-app-self-sufficient.png[width=900]

== C'est quoi le principe ?

image::dockerfile-flow.png[]

== ğŸ¤” Pourquoi fabriquer sa propre image ?

Essayez ces commandes dans Gitpod :

[source,bash]
----
cat /etc/os-release
# ...
git --version
# ...

# MÃªme version de Linux que dans GitPod
docker container run --rm ubuntu:20.04 git --version
# docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "git": executable file not found in $PATH: unknown.

# En interactif ?
docker container run --rm --tty --interactive ubuntu:20.04 git --version
----

=> ProblÃ¨me : git n'est mÃªme pas prÃ©sent !

== ğŸ“ Fabriquer sa premiÃ¨re image

* *But :* fabriquer une image Docker qui contient `git`

* Dans votre workspace Gitpod, crÃ©ez un dossier nommÃ© `docker-git/`
* Dans ce dossier, crÃ©er un fichier `Dockerfile` avec le contenu ci-dessous :
+
[source,Dockerfile]
----
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
----

* Fabriquez votre image avec la commande `docker image build --tag=docker-git <chemin/vers/docker-git/`

* Testez l'image fraÃ®chement fabriquÃ©e
** ğŸ’¡ `docker image ls`

== âœ… Fabriquer sa premiÃ¨re image

[source,bash]
----
cat <<EOF >Dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
EOF

docker image build --tag=docker-git ./

docker image ls | grep docker-git

# Doit fonctionner
docker container run --rm docker-git:latest git --version
----

== Conventions de nommage des images

[source]
----
[REGISTRY/][NAMESPACE/]NAME[:TAG|@DIGEST]
----

* Pas de Registre ? DÃ©faut: `registry.docker.com`
* Pas de Namespace ? DÃ©faut: `library`
* Pas de tag ? Valeur par dÃ©faut: `latest`
** âš ï¸ Friends don't let friends use `latest`
* Digest: signature unique basÃ©e sur le contenu

== Conventions de nommage : Exemples

* `ubuntu:20.04` => `registry.docker.com/library/ubuntu:20.04`
* `dduportal/docker-asciidoctor` => `registry.docker.com/dduportal/docker-asciidoctor:latest`
* `ghcr.io/dduportal/docker-asciidoctor:1.3.2@sha256:xxxx`

== ğŸ“ Utilisons les tags

* Il est temps de "taguer" votre premiÃ¨re image !
+
[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0
----

* Testez le fonctionnement avec le nouveau tag
* Comparez les 2 images dans la sortie de `docker image ls`

== âœ… Utilisons les tags

[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0

# 2 lignes
docker image ls | grep docker-git
# 1 ligne
docker image ls | grep docker-git | grep latest
# 1 ligne
docker image ls | grep docker-git | grep '1.0.0'

# Doit fonctionner
docker container run --rm docker-git:1.0.0 git --version
----

== ğŸ“ Mettre Ã  jour votre image (1.1.0)

* Mettez Ã  jour votre image en version `1.1.0` avec les changements suivants :
** Ajoutez un https://docs.docker.com/engine/reference/builder/#label[`LABEL`,window="_blank"] dont la clef est `description` (et la valeur de votre choix)
** Configurez `git` pour utiliser une branche `main` par dÃ©faut au lieu de `master` (commande `git config --global init.defaultBranch main`)

* Indices :
** ğŸ’¡ Commande `docker image inspect <image name>`
** ğŸ’¡ Commande `git config --get init.defaultBranch` (dans le conteneur)
** ğŸ’¡ Ajoutez des lignes *Ã  la fin* du `Dockerfile`
** ğŸ’¡ https://docs.docker.com/engine/reference/builder/[Documentation de rÃ©fÃ©rence des `Dockerfile`,window="_blank"]

== âœ… Mettre Ã  jour votre image (1.1.0)

[source,bash]
----
cat ./Dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
LABEL description="Une image contenant git prÃ©configurÃ©"
RUN git config --global init.defaultBranch main

docker image build -t docker-git:1.1.0 ./docker-git/
# Sending build context to Docker daemon  2.048kB
# Step 1/4 : FROM ubuntu:20.04
#  ---> e40cf56b4be3
# Step 2/4 : RUN apt-get update && apt-get install --yes --no-install-recommends git
#  ---> Using cache
#  ---> 926b8d87f128
# Step 3/4 : LABEL description="Une image contenant git prÃ©configurÃ©"
#  ---> Running in 0695fc62ecc8
# Removing intermediate container 0695fc62ecc8
#  ---> 68c7d4fb8c88
# Step 4/4 : RUN git config --global init.defaultBranch main
#  ---> Running in 7fb54ecf4070
# Removing intermediate container 7fb54ecf4070
#  ---> 2858ff394edb
Successfully built 2858ff394edb
Successfully tagged docker-git:1.1.0

docker container run --rm docker-git:1.0.0 git config --get init.defaultBranch
docker container run --rm docker-git:1.1.0 git config --get init.defaultBranch
# main
----

== Checkpoint ğŸ¯

* Une image Docker fournit un environnement de systÃ¨me de fichier auto-suffisant (application, dÃ©pendances, binaries, etc.) comme modÃ¨le de base d'un conteneur

* On peut spÃ©cifier une recette de fabrication d'image Ã  l'aide d'un `Dockerfile` et de la commande `docker image build`

* Les images Docker ont une convention de nommage permettant d'identifier les images trÃ¨s prÃ©cisÃ©ment

âš ï¸ Friends don't let friends use `latest` âš ï¸
