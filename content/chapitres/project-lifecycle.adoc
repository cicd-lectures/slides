[{invert}]
= Cycle de vie de votre projet

== ü§î Quel est le probl√®me ?

On a du code. C'est un bon d√©but. MAIS:

* Qu'est ce qu'on "fabrique" √† partir du code ?
* Comment faire pour "fabriquer" de la m√™me mani√®re pour tout‚Ä¢e‚Ä¢s (üíª | üñ• ) ?

== Que "fabrique" t'on √† partir du code ? üì¶

Un **livrable** :

* C'est ce que vos utilisateurs vont utiliser: un binaire √† t√©l√©charger ? L'application de production ?
* C'est versionn√©
* C'est __reproductible__

== Que signifie "reproductible" ?

* Il faut que notre processus de g√©n√©ration de livrable, (notre build) soit entierement **d√©terministe**.
* Il faut qu'en fonction d'un jeu de param√®tres, le r√©sultat du processus de livraison soit m√™me le "m√™me".

== Quels sont les param√®tres de notre livraison ?

* *Le code*: Dans quelle version est-il? Est-il fonctionnel? Est-ce qu'il est sauvegard√©?
* *Les d√©pendances de notre code*: Toutes les libraires utilis√©s dans notre application.
* *Les outils de g√©n√©ration de livrables*: Quel compilateur et dans quelle version?
* *L'environment d'ex√©cution cible*: Java 17 ou Java 20? Quelle version de PostgreSQL? Quel OS/Architecture CPU? Quel Navigateur?
* *Le processus de livraison lui m√™me*: Dans quelle mesure la proc√©dure de g√©n√©ration est elle r√©petable et respect√©e?

== Risques encourus?

* üò° Dans le meilleur des cas, votre app ne marche pas du tout.
* ü§° Dans certains cas votre app va casser sans explication facile et seulement sur la production du client les jours impairs d'une ann√©e bisextile.
** Allez reproduire et d√©bugger!
* üò± Livrer votre application va devenir une angoisse permanente
* üò±üò≠üî•‚ò†Ô∏è Vous livrez une CVE ou un malware, avec un acc√®s direct a votre base de donn√©es.
** link:https://jfrog.com/blog/malware-civil-war-malicious-npm-packages-targeting-malware-authors[Vraiment]
** link:https://www.theregister.com/2023/01/04/pypi_pytorch_dependency_attack[Vraiment, Vraiment]
** link:https://nvd.nist.gov/vuln/detail/CVE-2021-44228[Vraiment, Vraiment, Vraiment...]

== !

image::dumpster-fire.gif[caption="Dumpster Fire",width=1024]

== On en est o√π la dedans? (1/2)

* *Le code*
** ‚úÖ On vient de mettre en place git. On sait identifier une version par un hash de commit.
** ‚ùå On ne sait pas vraiment dire si l'application "fonctionne" ou pas.
* *Les d√©pendances de notre code*:
** ‚ùå On ne sait ni les r√©cup√©rer, ni les controller.
* *Les outils de g√©n√©ration de livrables*
** ‚ùå On sait que go1.22 est indiqu√© dans la documentation fournie mais c'est tout.

== On en est o√π la dedans? (2/2)

* *L'environment cible*:
** ‚ö†Ô∏è  La compilation Go g√©n√®re un binaire qui embarque son environment d'ex√©cution. C'est donc li√© √† la version du compilateur Go. Ce n'est pas le cas pour d'autres langages.
** ‚ùå Par contre on sait que l'on √† besoin de Postgres et Postgis, mais pas grand chose de plus!
** ‚úÖ Voi nous demande de cibler Linux >= 5.x sur une architecture CPU amd64
* *Le processus de livraison lui m√™me*:
** ‚ùå Nous n'avons encore rien d√©fini

== Quelles solutions ? (1/2)

* *Le code*
** ‚û°Ô∏è  *Solution* (pour savoir si il fonctionne): *les tests automatis√©s*
** ‚û°Ô∏è  *Solution* (pour garantir qu'il fonctionne √† chaque changement): *l'int√©gration continue (CI)*
* *Les d√©pendances du code*
** ‚û°Ô∏è  Solution: Mise en plase d'outils de **gestion et d'audit des d√©pendances**
* *Les outils de g√©n√©ration du code*:
** ‚û°Ô∏è  Solution: Mise en place d'un environement controll√© et automatis√© de g√©neration de livrable, via de la **Livraison Continue**

== Quelles solutions ? (2/2)

* *L'environment cible*:
** ‚û°Ô∏è  Solution: Utilisation *d'outils de packaging* (Docker) pour notre application et son environment cible
* *Le processus de livraison lui m√™me*:
** ‚û°Ô∏è  Solution: d√©finir un *cycle de vie* et en d√©duire un *processus de livraision*

== Le cycle de vie de notre application

* `build`: Compilation de l'application
* `lint`: Analyse statique de code pour d√©tecter des probl√®mes ou risques
* `test`:
** `unit_test`: Ex√©cution de tests unitaires
** `integration_test`: Ex√©cution des test d'int√©gration
* `package`: Cr√©ation du livrable
* `release`: Livraison du livrable

== Comment normaliser ce cycle de vie?

* Tout le monde peut jouer des commandes comme il le souhaite
* Il est n√©cessaire que tous les acteurs (d√©velopeurs et CI) jouent les m√™me commandes
* Utilisation d'un outil `normaliser` ces commandes
** ‚û°Ô∏è  On propose se propose d'utiliser `make`

== `make`, kesako?

* link:https://www.gnu.org/software/make/[GNU Make] est un outil en ligne de commande,
* qui lit un fichier `Makefile` pour ex√©cuter des t√¢ches.
* Chaque t√¢che (ou "r√®gle") est d√©crite par une "cible":
* Format d'une "cible" make :
+
[source,makefile]
----
cible: dependance
	commandes
----
* On appelle la commande `make` avec une ou plusieurs cibles en argument :
+
[source,bash]
----
make clean build
----

== Exemple de Makefile

[source,makefile]
----
# Fabrique le fichier "hello" (binaire) √† partir des fichier "hello.o" et "main.o"
hello: hello.o main.o
	gcc -o hello hello.o main.o

# Fabrique le fichier "hello.o" √† partir du code source "hello.c"
hello.o: hello.c
	gcc -o hello.o -c hello.c

# Fabrique le fichier "main.o" √† partir du code source "main.c"
main.o: main.c
	gcc -o main.o -c main.c
----

[source,bash]
----
make hello # Appelle implicitement "make hello.o" et "make main.o"
## √©quivalent √† "make hello.o main.o hello"
----

== üéì Exercice: Mettre en place un Makefile dans le Projet

* La compilation doit g√©n√©rer le binaire dans le r√©pertoire `dist`.
* On souhaite mettre en place un `Makefile` qui d√©finit les cibles suivantes:
** `dist`: cr√©e le r√©pertoire
** `clean`: supprime le r√©pertoire
** `all`: qui execute `clean` puis `dist`

== ‚úÖ Solution: Mettre en place un Makefile dans le Projet

[source,bash]
----
cd /workspace/vehicle-server
touch Makefile
----

[source,makefile]
----
all: clean dist

clean:
  rm -rf ./dist

dist:
  mkdir dist
----

== Makefile Avanc√© (1/2)

* Par d√©faut une cible/r√®gle correspond √† un fichier
** Si le fichier existe, `make` ne r√©-ex√©cutera pas les commandes
** ü§î Que se passe t'il si vous cr√©ez un fichier `all` dans le m√™me r√©pertoire que le Makefile?

== Makefile Avanc√© (2/2)

* Pour d√©sactiver ce comportement pour une cible donn√©e,
ajoutez ladite cible comme d√©pendance √† la cible sp√©ciale `.PHONY`
** On peut r√©p√©ter `.PHONY` plusieurs fois
** *convention*: on ajoute la cible √† .PHONY avant sa d√©finition

[source,makefile]
----
.PHONY: target
target: dependence
  commande
----

* Si vous appellez `make` sans argument,
alors la cible par d√©faut sera la premi√®re cible d√©finie

== üéì Exercice: Ajouter build dans le Makefile

* Mettez √† jour votre Makefile pour introduire une cible `build`
* `build` doit g√©n√©rer le binaire dans le r√©pertoire `./dist`
* `build` doit √™tre inclu dans la cible `all`
* `build` doit s'ex√©cuter m√™me si un fichier `build` existe

== ‚úÖ Solution: Ajouter build dans le Makefile

[source,makefile]
----
.PHONY: all
all: clean dist build

.PHONY: clean
clean:
  rm -rf ./dist

.PHONY: build
build:
  go build -o ./dist/server ./cmd/server

dist:
  mkdir ./dist
----

== üò± √ßa ne compile pas!

[source,bash]
----
go: cannot find main module, but found .git/config in /workspace/vehicle-server
        to create a module there, run:
        go mod init
----

On ne peut pas compiler sans avoir auparavant r√©gl√© la question des d√©pendances!

== !

Mais avant toute chose, un commit :)

== Checkpoint üéØ

On a vu dans ce chapitre:

* Ce qu'est la reproductibl√© des livrables et son importance
* On √† d√©fini un cycle de vie pour notre application
* On √† d√©couvert l'outil `make` pour impl√©menter ce cycle de vie
