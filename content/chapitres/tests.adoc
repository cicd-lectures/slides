[{invert}]
= Tests Automatis√©s
== Qu'est ce qu'un test ?

C'est du code qui v√©rifie que votre code fait ce qu'il est suppos√© faire.

== Pourquoi faire des tests ?

* Prouve que le logiciel se comporte comme attendu a tout moment.
* D√©tecte les impacts non anticip√©s des changements introduits
* Evite l'introduction de r√©gressions
* √âcrire des tests est un acte pr√©ventif et non curatif.

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de donn√©es

On parle de **SUT**, System Under Test.

== Diff√©rents syst√®mes, Diff√©rentes Techniques de Tests

* Test unitaire
* Test d'integration
* Test de bout en bout
* Smoke tests

(La terminologie varie d'un d√©veloppeur / langage / entreprise / √©cosyst√®me √† l'autre)

== Test unitaire

* Test validant le bon comportement une unit√© de code.
* Prouve que l'unit√© de code interagit correctement avec les autres unit√©s.
* Par exemple :
** Retourne les bonnes valeur en fonction des param√®tres donn√©s
** Appelle la bonne m√©thode du bon attribut avec les bons param√®tres

== Mise en place de l'exercice

* Depuis votre environnement de d√©veloppement, dans le repertoire du **fork** de votre bin√¥me
* Cr√©ez une feature branch `add-tests`.

== Ajout des Outils de Tests Unitaires au Projet (1/3)

L'execution de tests n√©cessite un outillage non ajout√© au projet

* Framework d'√©criture et d'execution de tests: `JUnit`
* Librairie de cr√©ation de mocks: `Mockito`
* Plugin maven de lancement de tests unitaires: `surefire`

== Cycle de Vie Maven et Tests

* Rappel : Maven d√©finit un cycle de vie de votre logiciel par phases:
* `surefire` ex√©cute les tests contenus dans tous les fichiers ayant le suffixe `Tests.java` (`MaClasseTests.java`)
* Le plugin `surefire` s‚Äôex√©cute (par d√©faut) lors de la phase `tests`
* Lancer `mvn test` va ex√©cuter les phases `validate` -> `compile` -> `test`

== Ajout des Outils de Tests Unitaires au Projet (2/3)

Ajoutez le bloc suivant au `pom.xml`

[source,xml]
----
<dependencies>
  <!-- ...  -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <configuration>
      <skipTests>${skipUnitTests}</skipTests>
    </configuration>
  </dependency>
  <!-- ...  -->
</dependencies>
----

== Ajout des Outils de Tests Automatis√©s au Projet (3/3)

* Ex√©cutez les tests unitaires avec la commande `mvn test`
** Spoiler : `No tests to run...`
** Pourquoi ca ?

image::https://media.giphy.com/media/5x89XRx3sBZFC/giphy.gif[]

== Exercice : Corriger un Bug (1/11)

* La classe `ListMenuService` semble √™tre "bugg√©e"...
** Tous les noms des menus sont *TEST TODO* üò±
* Quand on regarde l'impl√©mentation, on se rends compte que le probl√®me provient de la m√©thode statique `fromModel` de la classe `MenuDto`
* M√™me si la correction est ais√©e, on va d'abord √©crire un test unitaire qui valide le comportement du service.
* Notre SUT: `ListMenuService` + `DTO` + `Model`

== Exercice : Corriger un Bug (2/11)

Mise en place du test

[source,java]
--
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

public class ListMenuServiceTests {

  private ListMenuService subject;

  @BeforeEach
  public void init() {
    subject = new ListMenuService(null);
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsKnownMenus() {
     List<MenuDto> got = subject.listMenus();
  }
}
--

== Exercice : Corriger un Bug (3/11)

* Super on √† un test, il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler `java.lang.NullPointerException`

image::https://media.giphy.com/media/ceHKRKMR6Ojao/giphy.gif[]

== Exercice : Corriger un Bug (4/11)

* Le `ListMenuService` √† besoin d'un `MenuRepository` pour fonctionner.
* Cependant :
** On ne veut pas valider le comportement du `MenuRepository`, il est en dehors de notre SUT.
** Pire, on ne veut pas se connecter √† une base de donn√©e pendant un test unitaire.

== Exercice : Corriger un Bug (5/11)

Solution : On fournit une "fausse impl√©mentation" au service, un mock.

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

private MenuRepository menuRepository;

private ListMenuService subject;

@BeforeEach
public void init() {
  this.menuRepository = mock(MenuRepository.class);
  this.subject = new ListMenuService(this.menuRepository);
}
----

== Exercice : Corriger un Bug (6/11)

Ce "mock" peut √™tre pilot√© dans les tests!

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // Quand le repository re√ßoit l'appel findAll
  // Alors il retourne la valeur null.
  when(menuRepository.findAll()).thenReturn(null);
}
----

== Exercice : Corriger un Bug (7/11)

* Super on a un test unitaire, il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler: ‚úÖ

image::https://media.giphy.com/media/a0h7sAqON67nO/giphy.gif[]

== !

Sauf qu'on avait pas un bug √† corriger au fait?

== Exercice : Corriger un Bug (8/11)

Objectif: V√©rifier que les valeurs retourn√©es par le `ListMenuService` sont coh√©rentes
avec les donn√©es en base, pour cela il nous faut:

* Pr√©parer un jeu de donn√©es de test et configurer le mock du repository pour qu'il le retourne
* Appeler notre service
* Comparer le r√©sultat obtenu du service avec des valeurs attendues.

== Exercice : Corriger un Bug (9/11)

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // D√©fini une liste de menus avec un menus.
  Iterable<Menu> existingMenus = Arrays.asList(
    new Menu(
      Long.valueOf(1),
      "Christmas menu",
      new HashSet<>(
        Arrays.asList(
          new Dish(Long.valueOf(1), "Turkey", null),
          new Dish(Long.valueOf(2), "Pecan Pie", null)
        )
      )
    )
  );

  // On configure le menuRepository pour qu'il retourne notre liste de menus.
  when(menuRepository.findAll()).thenReturn(existingMenus);

  // On appelle notre sujet
  List<MenuDto> gotMenus = subject.listMenus();

  // On d√©fini wantMenus, les r√©sultats attendus
  Iterable<MenuDto> wantMenus = Arrays.asList(
      new MenuDto(
        Long.valueOf(1),
        "Christmas menu",
        new HashSet<>(
          Arrays.asList(
            new DishDto(Long.valueOf(1), "Turkey"),
            new DishDto(Long.valueOf(2), "Pecan Pie")
          )
        )
      )
    );

    // On compare la valeur obtenue avec la valeur attendue.
    assertEquals(wantMenus, gotMenus);
}
----

== Exercice : Corriger un Bug (10/11)

* Super on a un test unitaire (qui teste!), il ne reste plus qu'√† le lancer avec `mvn test` üéâ
* Spoiler:

[source,bash]
----
[ERROR] Failures:
[ERROR]   ListMenuServiceTests.listsKnownMenus:66
expected:
  <[MenuDto(id=1, name=Christmas menu, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
but was:
  <[MenuDto(id=1, name=TEST TODO, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
----

image::https://media.giphy.com/media/FG14fnY17opr2/giphy.gif[]

== Exercice : Corriger un Bug (11/11)

* Il ne reste plus qu'a faire la correction et le tour est jou√©!

image::https://media.giphy.com/media/111ebonMs90YLu/giphy.gif[width="800"]

== Tester la classe CreateMenuService

* Le `CreateMenuService` impl√©mente la logique de cr√©ation de menu au sein de l'application.
* Elle enregistre en base un nouveau menu avec tous ses plats
* Et r√©pond le nouveau menu enregistr√© en base
* En revanche, elle impl√©mente une logique de d√©duplication des plats par nom:
** Si un plat portant le m√™me nom existe d√©j√† en base, il est r√©utilis√© (pour √©viter la duplication)

On doit faire en sorte de v√©rifier ce comportement.

== V√©rifier les interactions avec les classes Mock√©es (1/2)

* Le but d'un test unitaire est de valider le comportement d'une m√©thode
* Par comportement nous entendons:
** Retourner les bonnes valeurs
** Appelle les bonnes m√©thodes des classes dont elle d√©pend, en passant les bons param√®tres.

== V√©rifier les interactions avec les classes Mock√©es (2/2)

[source,java]
----
// configure le mock pour qu'il retourne une instance de menu
when(menuRepository.save(any(Menu.class))).thenReturn(storedMenu);

// On appelle le code a tester...

// On d√©clare un ArgumentCaptor<Menu> (qui sert a capturer un argument)
ArgumentCaptor<Menu> savedMenuCaptor = ArgumentCaptor.forClass(Menu.class);

// On v√©rifie que la m√©thode `save` du menu repository √† √©t√© appel√©e une seule fois
// et on capture l'argument avec lequel elle a √©t√© appel√©e (le menu).
verify(menuRepository, times(1)).save(savedMenuCaptor.capture());

// On r√©cup√®re la valeur captur√©e pour pouvoir faire des assertions dessus.
savedMenu = savedMenuCaptor.getValue()
----

== Exercice: √âcrire un test qui prouve que `CreateMenuService` sauvegarde le menu

Plan de test

* On cr√©e une instance DishDTO qui repr√©sente le menu √† cr√©er
* On cr√©e une instance de Menu qui repr√©sente la valeur r√©pondue par la base de donn√©es
* On appelle `CreateMenuService.createMenu` avec notre DTO
* On capture le menu enregistr√© et on v√©rifie qu'il a les bonnes valeurs (et les bons plats).
* On v√©rifie que la valeur r√©pondue correspond √† ce que l'on attends.

== !

[source, java]
----
MenuDto newMenu = new MenuDto(
  null,
  "C'est l'anniversaire de Damien aujourd'hui!",
    new HashSet<DishDto>(
      Arrays.asList(
      new DishDto(null, "Turkey"),
      new DishDto(null, "Tiramisu")
    )
  )
);

Menu storedMenu = new Menu(
  Long.valueOf(1),
  "Christmas menu",
  new HashSet<Dish>(
    Arrays.asList(
      new Dish(Long.valueOf(2), "Turkey", null),
      new Dish(Long.valueOf(33), "Tiramisu", null)
    )
  )
);
----

== Exercice: √âcrire un test qui prouve que `CreateMenuService` r√©utilise les plats existants

Plan de test

* Similaire au pr√©c√©dent, en revanche avant d'appeler `createMenu` on demande au `dishRepository` de r√©pondre un Dish existant.
* On v√©rifie que l'instance de menu enregistr√©e r√©f√©rence bien le dish d√©j√† cr√©√©

[source,java]
----
// Instancie un nouveau dish ayant pour identifiant 33.
Dish existingDish = new Dish(Long.valueOf(33), "Tiramisu", null);

// Configure le mock du dish repository pour retourner le dish existant
// Quand il re√ßoit un appel a findByName avec la valeur ("tiramisu").
when(dishRepository.findByName("Tiramisu")).thenReturn(existingDish);
----

== Test Unitaire : Quelques R√®gles

* Un test unitaire teste un et un seul comportement
* Faites attention a ce que votre test teste vraiment quelque chose!
** Avec les mocks, c'est facile de se faire pi√©ger.
* Essayez, dans la mesure du possible, d'√©crire vos tests (qui √©chouent) avant d'√©crire votre code.
* Il n'y a pas de d√©finition ferme du SUT
** Attention √† garder une taille raisonnable (quelques classes).
* Privil√©giez les tests de m√©thodes publiques.

== Checkpoint üéØ

On a vu :

* üîç Qu'il faut tester son code
* üåç Qu'il existe diff√©rents type de tests en fonction de ce que l'on veut tester
* üß© Comment faire des tests unitaires

== Test Unitaire : Pro / Cons

* ‚úÖ Super rapides (<1s) et l√©gers a executer
* ‚úÖ Pousse √† avoir un bon design de code
* ‚úÖ Efficaces pour tester des cas limites
* ‚ùå Peu r√©alistes

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants ind√©pendamment ne prouve pas que le syst√®me fonctionne une fois int√©gr√©!

== Solution: Tests d'int√©gration

* Test validant qu‚Äôun assemblage d‚Äôunit√©s se comportent comme pr√©vu.
* Teste votre application au travers de toutes ses couches
* Par exemple avec menu server:
**  Prouve que GET /menus retourne la liste des menus enregistr√©s en base
**  Prouve que POST /menus enregistre un nouveau menu en base avec ses plats.

== D√©finition du SUT (1/2)

image::architecture.png[]

== D√©finition du SUT (2/2)

Une suite de tests d'int√©gration doit:

* D√©marrer et provisionner un environnement d‚Äôex√©cution (une DB, Elasticsearch, un autre service...)
* D√©marrer votre application
* Jouer un sc√©nario de test
* √âteindre et nettoyer son environnement d‚Äôex√©cution pour garantir l'isolation des tests

== !

Ce sont des tests plus lents et plus complexes que des tests unitaires. Comment g√©rer √ßa?

== Ex√©cuter Les Tests d‚ÄôInt√©gration: Cycle de Vie Maven

* Les tests d‚Äôint√©gration sont une autre partie du cycle de vie de l‚Äôapplication: la phase `verify`.
* `verify` est une m√©ta-phase compos√©e de 3 sous-phases :
** `pre-integration-test`: pr√©pare l'environnement des tests d‚Äôint√©gration
** `integration-test`: execute la suite de tests d'int√©gration
** `post-integration-test`: nettoie l'environnement des tests d‚Äôint√©gration

‚ö†Ô∏è Il faut toujours appeler `verify` et non pas `integration-test`, sinon la sous-phase`post-integration-test` ne s‚Äôex√©cutera pas ‚ö†Ô∏è

== Ex√©cuter Les Tests d‚ÄôInt√©gration: Le Plugin `failsafe` (1/3)

* Pour ex√©cuter les tests d‚Äôint√©gration nous allons introduire un nouveau plugin: `failsafe`
* Ce plugin ex√©cute les tests ayant le suffixe `IT.java` (par exemple: `MaClasseIT.java`)
* Ce plugin s‚Äôex√©cute lors de la phase `integration-test`

== Ex√©cuter Les Tests d‚ÄôInt√©gration: Le Plugin `failsafe` (2/3)

[source,xml]
----
<plugins>
  <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-failsafe-plugin</artifactId>
    <configuration>
      <skipTests>${skipIntegrationTests}</skipTests>
    </configuration>
  <plugin>
</plugins>
----

== Ex√©cuter Les Tests d‚ÄôInt√©gration: Le Plugin `failsafe` (2/3)

Cela cr√©e les commandes suivantes:

* `mvn test`: lance les tests unitaires
* `mvn verify`: lance les tests unitaires et d‚Äôint√©gration
* `mvn verify -DskipUnitTests=true`: lance uniquement les tests d‚Äôint√©gration

== Tests d‚ÄôInt√©grations: Et concr√®tement avec le menu-server?

* Dans les faits... nous n'allons pas utiliser les phases `pre-integration-test` et `post-integration-test`
** -> Nous n'avons pas de serveur de base de donn√©es a d√©marrer.
** -> SpringBoot int√®gre le d√©marrage et l‚Äôarr√™t du serveur web dans l‚Äôex√©cution des tests via l'annotation `@SprintBootTest`.
* C'est un projet p√©dagogique!
** Dans un "vrai" projet, on voudrait peut-√™tre d√©marrer / √©teindre un serveur de base de donn√©es dans ces √©tapes.

[{invert}]
== !

Nous allons √©crire un test d'int√©gration pour l'appel `GET /menus`

== Mise en Place d'un Test d'Int√©gration

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/controller/MenuControllerIT.java
// Lance l'application sur un port al√©atoire.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// Indique de relancer l'application √† chaque test.
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class MenuControllerIT {

  @LocalServerPort
  private int port;

  private URL getMenusURL() throws Exception {
    return new URL("http://localhost:" + port + "/menus");
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
  }
}
----

== Outillage fourni par SpringBoot

[source, java]
----
// Injecte automatiquement l'instance du menu repository
@Autowired
private MenuRepository menuRepository;

// Injecte automatiquement l'instance du TestRestTemplate
@Autowired
private TestRestTemplate template;

public void listExitingMenus() throws Exception {
   // Effectue une requ√™te GET /menus
   ResponseEntity<MenuDto[]> response = this.template.getForEntity(getMenusURL().toString(), MenuDto[].class);

   //Parse le payload de la r√©ponse sous forme d'array de MenuDto
   MenuDto[] gotMenus = response.getBody();
}
----

== Exercice: Impl√©mentez le test d'int√©gration de GET /menus

* Provisionne la base de donn√©e avec des donn√©es fixes
* Effectue une requ√™te HTTP sur `GET /menus`
* Parse la r√©ponse sous forme de `MenuDto`
* V√©rifie que le status de la r√©ponse est 200.
* Compare la r√©ponse √† un r√©sultat attendu de la m√™me fa√ßon que dans le test unitaire.

== Exercice: Impl√©mentez un test d'int√©gration pour DELETE /menus

* On cr√©e un menu en base
* On fait un appel a `DELETE /menus/{id}`
* On v√©rifie que le menu n'existe plus en base
* On v√©rifie que les dishes du menu n'existent plus en base

== Checkpoint üéØ

On a vu :

* ‚ùå Les limites des tests unitaires
* üè≠ Comment faire des tests d'int√©gration
* ü§î Tester n'est pas facile mais tr√®s utile

[{invert}]
= Encore plus d'int√©gration continue

C'est quand m√™me le sujet du cours :)

== Exercice: Activez les tests dans votre CI

Changez le workflow de ci de votre bin√¥me (ou le votre) pour qu'√† chaque build:

* Les tests unitaires soient lanc√©s
* Les tests d'integrations soient lanc√©s

üí° Pensez √† bien regarder le cycle de vie des phases Maven
