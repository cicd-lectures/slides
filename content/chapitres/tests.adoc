[{invert}]
= Tests AutomatisÃ©s
== Qu'est ce qu'un test ?

C'est du code qui vÃ©rifie que votre code fait ce qu'il est supposÃ© faire.

== Pourquoi faire des tests ?

* Prouve que le logiciel se comporte comme attendu a tout moment.
* DÃ©tecte les impacts non anticipÃ©s des changements introduits
* Evite l'introduction de rÃ©gressions
* Ã‰crire des tests est un acte prÃ©ventif et non curatif.

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de donnÃ©es

On parle de **SUT**, System Under Test.

== DiffÃ©rents systÃ¨mes, DiffÃ©rentes Techniques de Tests

* Test unitaire
* Test d'integration
* Test de bout en bout
* Smoke tests
* Test de performance

(La terminologie varie d'un dÃ©veloppeur / langage / entreprise / Ã©cosystÃ¨me Ã  l'autre)

== Test unitaire

* Test validant le bon comportement une unitÃ© de code.
* Prouve que l'unitÃ© de code interagit correctement avec les autres unitÃ©s.
* Par exemple :
** Retourne les bonnes valeur en fonction des paramÃ¨tres donnÃ©s
** Appelle la bonne mÃ©thode du bon attribut avec les bons paramÃ¨tres

== Mise en place de l'exercice

* Depuis votre environnement de dÃ©veloppement, dans le repertoire du **fork** de votre binÃ´me
* CrÃ©ez une feature branch `add-tests`.

== TODO REFAIRE TOUT CA avec go.

== Ajout des Outils de Tests AutomatisÃ©s au Projet (3/3)

* ExÃ©cutez les tests unitaires avec la commande `mvn test`
** Spoiler : `No tests to run...`
** Pourquoi ca ?

image::https://media.giphy.com/media/5x89XRx3sBZFC/giphy.gif[]

== ğŸ“ Exercice : Corriger un Bug (1/11)

* La classe `ListMenuService` semble Ãªtre "buggÃ©e"...
** Tous les noms des menus sont *TEST TODO* ğŸ˜±
* Quand on regarde l'implÃ©mentation, on se rends compte que le problÃ¨me provient de la mÃ©thode statique `fromModel` de la classe `MenuDto`
* MÃªme si la correction est aisÃ©e, on va d'abord Ã©crire un test unitaire qui valide le comportement du service.
* Notre SUT: `ListMenuService` + `DTO` + `Model`

== ğŸ“ Exercice : Corriger un Bug (2/11)

Mise en place du test

[source,java]
--
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

public class ListMenuServiceTests {

  private ListMenuService subject;

  @BeforeEach
  public void init() {
    subject = new ListMenuService(null);
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsKnownMenus() {
     List<MenuDto> got = subject.listMenus();
  }
}
--

== ğŸ“ Exercice : Corriger un Bug (3/11)

* Super on Ã  un test, il ne reste plus qu'Ã  le lancer avec `mvn test` ğŸ‰
* Spoiler `java.lang.NullPointerException`

image::https://media.giphy.com/media/ceHKRKMR6Ojao/giphy.gif[]

== ğŸ“ Exercice : Corriger un Bug (4/11)

* Le `ListMenuService` Ã  besoin d'un `MenuRepository` pour fonctionner.
* Cependant :
** On ne veut pas valider le comportement du `MenuRepository`, il est en dehors de notre SUT.
** Pire, on ne veut pas se connecter Ã  une base de donnÃ©e pendant un test unitaire.

== ğŸ“ Exercice : Corriger un Bug (5/11)

Solution : On fournit une "fausse implÃ©mentation" au service, un mock.

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

private MenuRepository menuRepository;

private ListMenuService subject;

@BeforeEach
public void init() {
  this.menuRepository = mock(MenuRepository.class);
  this.subject = new ListMenuService(this.menuRepository);
}
----

== ğŸ“ Exercice : Corriger un Bug (6/11)

Ce "mock" peut Ãªtre pilotÃ© dans les tests!

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // Quand le repository reÃ§oit l'appel findAll
  // Alors il retourne la valeur null.
  when(menuRepository.findAll()).thenReturn(null);
}
----

== ğŸ“ Exercice : Corriger un Bug (7/11)

* Super on a un test unitaire, il ne reste plus qu'Ã  le lancer avec `mvn test` ğŸ‰
* Spoiler: âœ…

image::https://media.giphy.com/media/a0h7sAqON67nO/giphy.gif[]

== !

Sauf qu'on avait pas un bug Ã  corriger au fait?

== ğŸ“ Exercice : Corriger un Bug (8/11)

Objectif: VÃ©rifier que les valeurs retournÃ©es par le `ListMenuService` sont cohÃ©rentes
avec les donnÃ©es en base, pour cela il nous faut:

* PrÃ©parer un jeu de donnÃ©es de test et configurer le mock du repository pour qu'il le retourne
* Appeler notre service
* Comparer le rÃ©sultat obtenu du service avec des valeurs attendues.

== ğŸ“ Exercice : Corriger un Bug (9/11)

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // DÃ©fini une liste de menus avec un menus.
  Iterable<Menu> existingMenus = Arrays.asList(
    new Menu(
      Long.valueOf(1),
      "Christmas menu",
      new HashSet<>(
        Arrays.asList(
          new Dish(Long.valueOf(1), "Turkey", null),
          new Dish(Long.valueOf(2), "Pecan Pie", null)
        )
      )
    )
  );

  // On configure le menuRepository pour qu'il retourne notre liste de menus.
  when(menuRepository.findAll()).thenReturn(existingMenus);

  // On appelle notre sujet
  List<MenuDto> gotMenus = subject.listMenus();

  // On dÃ©fini wantMenus, les rÃ©sultats attendus
  Iterable<MenuDto> wantMenus = Arrays.asList(
      new MenuDto(
        Long.valueOf(1),
        "Christmas menu",
        new HashSet<>(
          Arrays.asList(
            new DishDto(Long.valueOf(1), "Turkey"),
            new DishDto(Long.valueOf(2), "Pecan Pie")
          )
        )
      )
    );

    // On compare la valeur obtenue avec la valeur attendue.
    assertEquals(wantMenus, gotMenus);
}
----

== ğŸ“ Exercice : Corriger un Bug (10/11)

* Super on a un test unitaire (qui teste!), il ne reste plus qu'Ã  le lancer avec `mvn test` ğŸ‰
* Spoiler:

[source,bash]
----
[ERROR] Failures:
[ERROR]   ListMenuServiceTests.listsKnownMenus:66
expected:
  <[MenuDto(id=1, name=Christmas menu, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
but was:
  <[MenuDto(id=1, name=TEST TODO, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
----

image::https://media.giphy.com/media/FG14fnY17opr2/giphy.gif[]

== ğŸ“ Exercice : Corriger un Bug (11/11)

* Il ne reste plus qu'a faire la correction et le tour est jouÃ©!

image::https://media.giphy.com/media/111ebonMs90YLu/giphy.gif[width="800"]

== Test Unitaire : Quelques RÃ¨gles

* Un test unitaire teste un et un seul comportement
* Faites attention a ce que votre test teste vraiment quelque chose!
** Avec les mocks, c'est facile de se faire piÃ©ger.
* Essayez, dans la mesure du possible, d'Ã©crire vos tests (qui Ã©chouent) avant d'Ã©crire votre code.
* Il n'y a pas de dÃ©finition ferme du SUT
** Attention Ã  garder une taille raisonnable (quelques classes).
* PrivilÃ©giez les tests de mÃ©thodes publiques.

== Checkpoint ğŸ¯

On a vu :

* ğŸ” Qu'il faut tester son code
* ğŸŒ Qu'il existe diffÃ©rents type de tests en fonction de ce que l'on veut tester
* ğŸ§© Comment faire des tests unitaires

== Test Unitaire : Pro / Cons

* âœ… Super rapides (<1s) et lÃ©gers a executer
* âœ… Pousse Ã  avoir un bon design de code
* âœ… Efficaces pour tester des cas limites
* âŒ Peu rÃ©alistes

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants indÃ©pendamment ne prouve pas que le systÃ¨me fonctionne une fois intÃ©grÃ©!

== âœ… Solution: Tests d'intÃ©gration

* Test validant quâ€™un assemblage dâ€™unitÃ©s se comportent comme prÃ©vu.
* Teste votre application au travers de toutes ses couches
* Par exemple avec menu server:
**  Prouve que GET /menus retourne la liste des menus enregistrÃ©s en base
**  Prouve que POST /menus enregistre un nouveau menu en base avec ses plats.

== DÃ©finition du SUT (1/2)

image::architecture.png[]

== DÃ©finition du SUT (2/2)

Une suite de tests d'intÃ©gration doit:

* DÃ©marrer et provisionner un environnement dâ€™exÃ©cution (une DB, Elasticsearch, un autre service...)
* DÃ©marrer votre application
* Jouer un scÃ©nario de test
* Ã‰teindre et nettoyer son environnement dâ€™exÃ©cution pour garantir l'isolation des tests

== !

Ce sont des tests plus lents et plus complexes que des tests unitaires. Comment gÃ©rer Ã§a?

== ExÃ©cuter Les Tests dâ€™IntÃ©gration: Cycle de Vie Maven

* Les tests dâ€™intÃ©gration sont une autre partie du cycle de vie de lâ€™application: la phase `verify`.
* `verify` est une mÃ©ta-phase composÃ©e de 3 sous-phases :
** `pre-integration-test`: prÃ©pare l'environnement des tests dâ€™intÃ©gration
** `integration-test`: execute la suite de tests d'intÃ©gration
** `post-integration-test`: nettoie l'environnement des tests dâ€™intÃ©gration

âš ï¸ Il faut toujours appeler `verify` et non pas `integration-test`, sinon la sous-phase `post-integration-test` ne sâ€™exÃ©cutera pas âš ï¸

== ExÃ©cuter Les Tests dâ€™IntÃ©gration: Le Plugin `failsafe` (1/3)

* Pour exÃ©cuter les tests dâ€™intÃ©gration nous allons introduire un nouveau plugin: `failsafe`
* Ce plugin exÃ©cute les tests ayant le suffixe `IT.java` (par exemple: `MaClasseIT.java`)
* Ce plugin sâ€™exÃ©cute lors de la phase `integration-test`

== ExÃ©cuter Les Tests dâ€™IntÃ©gration: Le Plugin `failsafe` (2/3)

* Configurez le plugin Maven Spring Boot pour les tests d'intÃ©gration (section `<build><plugins>`):

[source,xml]
----
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-failsafe-plugin</artifactId>
  <configuration>
    <skipTests>${skipIntegrationTests}</skipTests>
  </configuration>
</plugin>
----

== ExÃ©cuter Les Tests dâ€™IntÃ©gration: Le Plugin `failsafe` (2/3)

Cela crÃ©e les commandes suivantes:

* `mvn test`: lance les tests unitaires
* `mvn verify`: lance les tests unitaires et dâ€™intÃ©gration
* `mvn verify -DskipUnitTests=true`: lance uniquement les tests dâ€™intÃ©gration

== Tests dâ€™IntÃ©grations: Et concrÃ¨tement avec le menu-server?

* Dans les faits... nous n'allons pas utiliser les phases `pre-integration-test` et `post-integration-test`
** -> Nous n'avons pas de serveur de base de donnÃ©es a dÃ©marrer.
** -> SpringBoot intÃ¨gre le dÃ©marrage et lâ€™arrÃªt du serveur web dans lâ€™exÃ©cution des tests via l'annotation `@SprintBootTest`.
* C'est un projet pÃ©dagogique!
** Dans un "vrai" projet, on voudrait peut-Ãªtre dÃ©marrer / Ã©teindre un serveur de base de donnÃ©es dans ces Ã©tapes.

[{invert}]
== !

Nous allons Ã©crire un test d'intÃ©gration pour l'appel `GET /menus`

== ğŸ“ Exercice : Ecrire un test d'integration (1/4)

Mise en place d'un test vide

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/controller/MenuControllerIT.java
// Lance l'application sur un port alÃ©atoire.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// Indique de relancer l'application Ã  chaque test.
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class MenuControllerIT {

  @LocalServerPort
  private int port;

  private URL getMenusURL() throws Exception {
    return new URL("http://localhost:" + port + "/menus");
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
  }
}
----

== ğŸ“ Exercice : Ecrire un test d'integration (2/4)

Maintenant, on appelle le serveur et on verifie que l'appelle qu'il nous reponds une 200

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/controller/MenuControllerIT.java
// Lance l'application sur un port alÃ©atoire.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// Indique de relancer l'application Ã  chaque test.
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class MenuControllerIT {
  // ...
  
  private RestTemplate template = new RestTemplate();

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
    ResponseEntity<MenuDto[]> response = this.template.getForEntity(getMenusURL().toString(), MenuDto[].class);

    assertEquals(HttpStatus.OK, response.getStatusCode());
  }
}
----


[{invert}]
== !

Bon, c'est bien sympa mais notre test n'est pas satisfaisant en l'etat. Il faut maintenat valider notre comportement pricipal: lister tous les menus connus

== ğŸ“ Exercice : Ecrire un test d'integration (3/4)

D'abord il faut provisionner des donnÃ©es en base.

[source, java]
----
public class MenuControllerIT {
  // ...
  // Injecte automatiquement l'instance du menu repository
  @Autowired
  private MenuRepository menuRepository;

  private final List<Menu> existingMenus = Arrays.asList(
      new Menu(null, "Christmas menu", new HashSet<>(Arrays.asList(new Dish(null, "Turkey", null), new Dish(null, "Pecan Pie", null)))),
      new Menu(null, "New year's eve menu", new HashSet<>(Arrays.asList(new Dish(null, "Potatos", null), new Dish(null, "Tiramisu", null)))));


  @BeforeEach
  public void initDataset() {
    for (Menu menu : existingMenus) {
      menuRepository.save(menu);
    }
  }

  // ...
}
----

== ğŸ“ Exercice : Ecrire un test d'integration (4/4)

Il ne nous reste qu'a changer le corps du test pour verifier que le contenu de la reponse est celui auquel on s'attends.

[source, java]
----

public class MenuControllerIT {
  // ...

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
    // On declare la valeur attendue.
    MenuDto[] wantMenus = {
        new MenuDto(Long.valueOf(1), "Christmas menu",
            new HashSet<DishDto>(
                Arrays.asList(new DishDto(Long.valueOf(1), "Turkey"), new DishDto(Long.valueOf(2), "Pecan Pie")))),
        new MenuDto(Long.valueOf(2), "New year's eve menu", new HashSet<DishDto>(
            Arrays.asList(new DishDto(Long.valueOf(3), "Potatos"), new DishDto(Long.valueOf(4), "Tiramisu")))) };

    // On fait la requÃªte et on recupere la reponse.
    ResponseEntity<MenuDto[]> response = this.template.getForEntity(getMenusURL().toString(), MenuDto[].class);

    // On verifie le status de reponse.
    assertEquals(HttpStatus.OK, response.getStatusCode());

    // On list le corps de la reponse.
    MenuDto[] gotMenus = response.getBody();

    // On verifie que la reponse est la meme que celle attendue.
    assertArrayEquals(wantMenus, gotMenus);
  }
}
----

== ğŸ“ Exercice: Activez les tests dans votre CI

Changez le workflow de ci de votre binÃ´me (ou le votre) pour qu'Ã  chaque build:

* Les tests unitaires soient lancÃ©s
* Les tests d'integrations soient lancÃ©s

ğŸ’¡ Pensez Ã  bien regarder le cycle de vie des phases Maven

// TODO: solution

// Todo add a bullet
== Checkpoint ğŸ¯

On a vu :

* âŒ Les limites des tests unitaires
* ğŸ­ Comment faire des tests d'intÃ©gration
* ğŸ¤” Tester n'est pas facile mais trÃ¨s utile
