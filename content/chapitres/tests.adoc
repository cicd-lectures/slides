[{invert}]
= Tests AutomatisÃ©s

== Qu'est ce qu'un test ?

C'est du code qui vÃ©rifie que votre code fait ce qu'il est supposÃ© faire.

== Pourquoi faire des tests ?

* Prouve que le logiciel se comporte comme attendu Ã  tout moment
* DÃ©tecte les impacts non anticipÃ©s des changements introduits

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de donnÃ©es

On parle de **SUT**, System Under Test.

== DiffÃ©rents systÃ¨mes, DiffÃ©rentes Techniques de Tests

* Test unitaire
* Test d'intÃ©gration
* Test de bout en bout
* Smoke tests
* Test de performance

(La terminologie varie d'un dÃ©veloppeur / langage / entreprise / Ã©cosystÃ¨me Ã  l'autre)

== Test unitaire

* Test validant le bon comportement une unitÃ© de code
* Prouve que l'unitÃ© de code interagit correctement avec les autres unitÃ©s.
* Les autres composants dont l'unitÃ© de code dÃ©pends sont "bouchonnÃ©s", cela pour garantir leur simplicitÃ© et leur facilitÃ©.
** Par Exemple: la couche d'accÃ¨s a la base de donnÃ©es est rÃ©implÃ©mentÃ©e en mÃ©moire.


== Tests & Go

* Go embarque un framework de tests intÃ©grÃ© a la CLI `go`, la commande `go test`
* Les tests sont Ã©crit dans un fichier `_test.go` apposÃ© au fichier testÃ©
* `go test` dÃ©couvre touts les fichiers de tests d'un module et joue tous les tests implÃ©mentÃ©s dans ces fichiers.
** Un test est une fonction qui commence par `Test` et qui accepte en paramÃ¨tre un pointeur sur `testing.T`

== !

[source,go]
----
include::../code-samples/go/examples_test.go[tags="basic"]
----

== Tests ParamÃ©triques

* On veut tester la mÃªme mÃ©thode avec plusieurs valeurs d'entrÃ©es
* Cela crÃ©e pas mal de duplication
* *Solution*: On utilise des tests paramÃ©triques qui factorisent le code du test et variabilise les valeurs d'entrÃ©es et les valeurs attendues

== !

[source,go]
----
include::../code-samples/go/examples_test.go[tags="table_driven"]
----

== ExÃ©cutons les Tests du Package vehicle

On exÃ©cute les tests d'un package particulier avec la commande suivante.

[source,bash]
----
go test -v ./vehicle
----

Quel est le rÃ©sultat?

== !

ğŸ¤” Il semblerait que quelque chose ne se passe pas comme prÃ©vu...

== ğŸ“ Exercice: Corrigez Le Bug ğŸ›

* Ã€ l'aide de la sortie du test, essayez de dÃ©terminer d'oÃ¹ peut venir le problÃ¨me.
* Quelques questions pour vous aider:
** Quel mÃ©thode est testÃ©e? Dans quel fichier se trouve t'elle? Que doit faire cette mÃ©thode?
** Quel comportement est testÃ© par le cas de test?
** Quel code HTTP est attendu? RetournÃ©? Que signifient t'ils?
* Une fois le problÃ¨me clairement identifiÃ©, proposez un changement qui valide ce cas de test.

âš ï¸ On ne change / supprime pas le code du test âš ï¸

== âœ… Solution: Corrigez Le Bug ğŸ›

[source,go]
----
// vehicle/create.go:l26

if len(f.ShortCode) > 4 {
  validationIssues = append(validationIssues, "short code too long")
}
----

== ğŸ“ Exercice: Ajoutez La Target `unit_test` au Makefile

* Pour faciliter l'exÃ©cution de toute la suite de tests, ajoutez la cible `unit_test` Ã  votre Makefile pour que les tests de tous les packages soit jouÃ©s.
* Avec le mode verbeux activÃ© par dÃ©faut
** Indice: `go help test` et `go help packages`
* *Bonus*: Activez le calcul de la couverture de tests

== âœ… Solution: Ajoutez La Target `unit_test` au Makefile

[source,Makefile]
----
.PHONY: unit_test
unit_test:
  go test -v -cover ./...
----

== Test Unitaire : Pro / Cons

* âœ… Super rapides (<1s) et lÃ©gers a exÃ©cuter
* âœ… Pousse Ã  avoir un bon design de code
* âœ… Efficaces pour tester des cas limites
* âŒ Environnement "aseptisÃ©" et "bouchonnÃ©", dÃ©fini par le dÃ©veloppeur
* âŒ "Ossifie" le code

== Le pÃ©rimÃ¨tre testÃ© est-il satisfaisant?

* La suite de tests qui vient de casser teste la logique de validation de la requÃªte reÃ§ue.
* Est-ce que cela est suffisant pour prouver que la fonctionnalitÃ© "crÃ©er un vÃ©hicule" fonctionne ?

== !

* Pas exactement, d'autres composants entrent en jeu dans l'environnement rÃ©el
** La couche de communication avec la base de donnÃ©es, le routage HTTP...

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants indÃ©pendamment ne prouve pas que le systÃ¨me fonctionne une fois intÃ©grÃ©!

== âœ… Solution: Tests d'intÃ©gration

* Test validant que l'assemblage de composants se comportent comme prÃ©vu.
* Teste votre application au travers de tous ses composants
* Par exemple avec vehicle-server:
**  Prouve que GET /vehicles retourne la liste des vÃ©hicules les plus proche d'un point donnÃ©
**  Prouve que POST /vehicles enregistre un nouveau vÃ©hicule en base.

== DÃ©finition du SUT

Une suite de tests d'intÃ©gration doit:

* DÃ©marrer et provisionner un environnement dâ€™exÃ©cution (une DB, Elasticsearch, un autre service...)
* DÃ©marrer votre application
* Jouer un scÃ©nario de test
* Ã‰teindre et nettoyer son environnement dâ€™exÃ©cution pour garantir l'isolation des tests

â¡ï¸ On se place ici d'un point de vue extÃ©rieur Ã  l'application

== !

* âŒ Ce sont des tests plus lents et plus complexes que des tests unitaires.
* â³Tout tester avec des tests d'intÃ©gration n'est pas efficace
* â¡ï¸ Il faut Ã©quilibrer les deux stratÃ©gies

== Et concrÃ¨tement avec le notre projet?

* La suite de test d'intÃ©gration se situe dans le fichier `app_test.go`
* Il y a un cas par fonctionnalitÃ© principale de l'application (create vehicle, delete vehicle, list vehicles)

== !

* La gestion de l'environnement est "cachÃ©e":
** DÃ©marrer un container de base de donnÃ©es (Postgres avec Postgis)
** DÃ©marrer une instance de l'application
** Tout Ã©teindre une fois terminÃ©

C'est fait dans le fichier `app/helper_test.go` si vous voulez ğŸ‘€

== Lancez les tests d'intÃ©gration

* Vous pouvez lancer les tests d'intÃ©gration avec la commande suivante.

[source,go]
----
go test -v -count=1 --tags=integration ./app
----

== ğŸ“ Exercice: Corrigez votre ImplÃ©mentation de Delete Vehicle

Optionnel mais, si les tests d'intÃ©gration Ã©chouent Ã  ce point, il serait bon de corriger votre implÃ©mentation de la suppression de vÃ©hicule.

== ğŸ“ Exercice: Activez les tests dans votre CI

Changez le workflow de ci de votre binÃ´me (ou le votre) pour qu'Ã  chaque build:

* Les tests unitaires soient lancÃ©s
* Les tests d'intÃ©gration soient lancÃ©s
** N'oubliez pas de dÃ©finir une nouvelle cible integration_test dans le Makefile

== âœ… Solution: Activez les tests dans votre CI

[source,yaml]
----
include::../code-samples/gh-actions/vehicle-server.yml[tags="!*;pr;ci"]
----

== Checkpoint ğŸ¯

On a vu :

* âŒ Les avantages et limites des diffÃ©rentes stratÃ©gies de tests...
* âš–ï¸ ... et la nÃ©cessitÃ© d'avoir une stratÃ©gie Ã©quilibrÃ©e.

ğŸ‰ Vous pouvez enfin merger votre PR!
