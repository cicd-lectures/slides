
[{invert}]
= Tests automatisés

Faire en sorte qu'on ne casse pas tout quand on change quelque chose...

== Qu'est ce qu'un test ?

* C'est du code qui vérifie qu'un système fait ce qu'il est supposé faire.
* Ecrire des tests est un acte préventif et non curratif.

== Pourquoi faire des tests ?

* Ça sert a prouver que le logiciel se comporte comme attendu a tout moment.
* Ça permet de détecter au plus tôt les problèmes.

[.notes]
--
* Cela ne permet pas de corriger des bugs, cela limite le risque d'en introduire.
--

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de données

On parle de SUT, System Under Test.

== Différents systemes, différents types de tests

* Test unitaire
* Test d'integration
* Test de bout en bout

== Test unitaire

* Test validant le bon comportement une unité de code (fonction, méthode...)
* Prouve que l'unité de code interagit correctement avec les autres unités.
* Par exemple:
** Retourne les bonnes valeur en fonction des paramètres donnés
** Appelle la bonne methode du bon attribut avec les bons paramètres

== Test Unitaire: Mise en place

```bash
git clone https://github.com/cicd-lectures/demoapp.git
cd demoapp
git checkout ut-exercise-1

# Run the tests
mvnw test
```

== Test Unitaire: Exercice 1

Implementez la methode `greet` de la classe `GreeterService`

* Si l'age de l'utilisateur est inferieur a 10, alors retourner "Hi"
* Si l'age de l'utilisateur est entre 10 et 20, alors retourner "Hey"
* Si l'age de l'utilisateur est supérieur a 20, alors retourner "Hello"

== La classe `GreeterService`

[source,java]
--
// src/main/java/com/cicdlectures/demoapp/user/GreeterService.java

public class GreeterService {

  public String greet(User user) {
    // TODO
  }

}
--

== La classe `User`

[source,java]
--
// src/main/java/com/cicdlectures/demoapp/user/User.java

public class User {

  private int age;

  public User(String name, int age) {
    //...
    this.age = age;
  }

  public int getAge() {
    return this.age;
  }
}
--

== La classe `GreeterServiceTests`

[source,java]
--
// src/test/java/com/cicdlectures/demoapp/user/GreeterServiceTests.java

class GreeterServiceTests {

  private GreeterService subject;

  @BeforeEach
  public void init() {
    this.subject = new GreeterService();
  }

  @Test
  void greetsUserWithAgeBelow10WithHi() {
    // ...
  }
}
--


== Un exemple de test

[source,java]
--
// src/test/java/com/cicdlectures/demoapp/user/GreeterServiceTests.java

  @Test
  @DisplayName("greets user with age below 10 with Hi")
  void greetsUserWithAgeBelow10WithHi() {
    // Instancier un nouvel utilisateur.
    User user = new User("John", 5);

    // Appeler la methode a tester.
    String result = this.subject.greet(user);

    // Verifier le résutat.
    assertEquals("Hi", got);
  }

--

== Implémentation du premier cas

[source,java]
--
// src/main/java/com/cicdlectures/demoapp/user/GreeterService.java

  public String greet(User user) {
    if (user.getAge() < 10) {
      return "Hi";
    }

    //...
  }
--


== A vous de jouer pour les deux autres cas :)

[source,java]
--
  @Test
  @DisplayName("greets user with age between 10 and 20 with Hey")
  void greetsUserWithAgeBetween10And20WithHey() {
    fail("Not implemented");
  }

  @Test
  @DisplayName("greets user above 20 with Hello")
  void greetsUserWithAgeBelow10WithHello() {
    fail("Not implemented");
  }
--

== Test Unitaire: Solution Exercice 1

```bash
git checkout ut-exercise-1-solution
```

== Test Unitaire: Exercice 2

Implementez la methode `createUser` de la classe `UserService`

* Si un utilisateur porte le même nom, alors on ne le sauvegarde pas
* Si il n'existe pas, alors on le crée

== Base de donnée ?

[source,java]
--
public interface UserRepository {

    // Enregistre l'utilisateur en base de donnée.
    public void saveUser(User user);

    // Retourne l'utilisateur en base qui porte le nom passé en parmètre.
    // Retourne `null` si aucun utilisateur portant le nom existe.
    public User findByName(String user);
}
--

== La classe `UserService`

[source,java]
--
public class UserService {

  private UserRepository repo;

  public UserService(UserRepository repo) {
    this.repo = repo;
  }

  public void createUser(User user) {
    // Regarde si un utilisteur avec ce nom existe en base.

    // Sauvegarde l'utilisateur si l'utilisateur n'existe pas.
  }
}
--

== Comment tester uniquement la classe `UserService` ?

* Le `UserService` à besoin d'un `UserRepository` pour fonctionner.
* Cependant:
** On ne veut pas valider le comportement du `UserRepository`.
** Pire, on ne veut pas se connecter à une base de donnée pendant un test unitaire.

== Remplacer le UserRepository (1/3)

Solution: On fournit une "fausse implémentation"

[source,java]
--
  private UserRepository repository;

  private UserService subject;

  @BeforeEach
  public void init() {
    this.repository = mock(UserRepository.class);
    this.subject = new UserService(this.repository);
  }
--

== Remplacer le UserRepository (2/3)

que l'on pilote dans les tests!

[source,java]
--
  @Test
  public void createsUser() {
    // Quand le repository reçoit l'appel findByName avec la valeur "foo"
    // Alors il retourne null.
    when(repository.findByName("foo")).thenReturn(null);
  }
--

== Remplacer le UserRepository (3/3)

et on valide les interactions avec cette instance!

[source,java]
--
  @Test
  public void createsUser() {
    User user = new User("foo", 10);
    // [...]
    // Verifie que l'instance de repository a reçu saveUser avec l'objet user.
    verify(this.repository).saveUser(user);
  }
--

== Résumé

[source,java]
--
  @Test
  @DisplayName("creates an user")
  public void createsUser() {
    User user = new User("foo", 10);
    when(repository.findByName("foo")).thenReturn(null);

    subject.createUser(user);

    verify(this.repository).saveUser(user);
  }
--

== A vous de jouer pour l'autre cas :)

[source,java]
--
  @Test
  @DisplayName("does not create a user if it already exists")
  public void doesNotcreateUserIfAlreadyExist() {
    fail("not implemented");
  }
--

[source, java]
--
  // Un peu d'aide :)

  // Retourne l'utilisateur passé en paramètre.
  when(repository.findByName("foo")).thenReturn(user);

  // Vérifie que la methode saveUser du repository n'est
  // jamais appelé avec l'instance user.
  verify(this.repository, never()).saveUser(user);
--

== Test Unitaire: Pro / Cons

* (+) Super rapides (<1s) et légers a executer
* (+) Pousse à avoir un bon design de code
* (+) Efficaces pour tester des cas limites
* (-) Peu réaliste

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

== Test d'Integration

* Test validant qu'un assemblage d'unités se comportent comme prévu.
* Par exemple:
** Prouve que `GET /users` retourne la liste des utilisateurs en base
** Prouve que `POST /users`  avec un nom manquant provoque une réponse HTTP 400

Prouve le bon comportement d'une partie de l'application.

== Test d'Integration: Demonstration

== Test d'Integration: Pro / Cons

* (+) Rapides (~1s) a executer
* (+) Relativement réalistes
* (-) Potentiellement complexes
* (-) Moins flexibles

== Test de Bout en Bout

* Test validant qu'un cas d'utilisation est correctement implémenté par le logiciel
* Tests idéalement décrits de façon non technique
* Par exemple:
** En tant qu'un utilisateur authentifié
** Quand je remplis le formulaire correctement et appuie sur le bouton "OK"
** Alors un utilisateur est créé en base

== Demonstration

== Test de Bout en Bout: Pro / Cons

* (+) Au plus proche d'un cas réel
* (+) Teste tous les composants du logiciel
* (-) Lents (~1m)
* (-) Complexes
* (-) Peu flexibles
