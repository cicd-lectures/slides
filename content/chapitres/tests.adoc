[{invert}]
= Tests Automatis√©s
== Qu'est ce qu'un test ?

C'est du code qui v√©rifie que du code fait ce qu'il est suppos√© faire.

== Pourquoi faire des tests ?

* √áa sert a prouver que le logiciel se comporte comme attendu a tout moment.
* D√©tecte les impacts non anticip√©s des changements introduits
* Evite l'introduction de r√©gressions
* Ecrire des tests est un acte pr√©ventif et non curratif.

== Qu'est ce que l'on teste ?

* Une fonction
* Une combinaison de classes
* Un serveur applicatif et une base de donn√©es

On parle de **SUT**, System Under Test.

== Diff√©rents systemes, Diff√©rentes Techniques de Tests

* Test unitaire
* Test d'integration
* Test de bout en bout
* Smoke tests

(La terminologie varie d'un d√©veloppeur / langage / entreprise / ecosyst√®me √† l'autre)

== Test unitaire

* Test validant le bon comportement une unit√© de code.
* Prouve que l'unit√© de code interagit correctement avec les autres unit√©s.
* Un test d√©crit un cas
* Par exemple :
** Retourne les bonnes valeur en fonction des param√®tres donn√©s
** Appelle la bonne methode du bon attribut avec les bons param√®tres

== Mise en place de l'exercice

* Depuis votre environement de d√©veloppement, dans le repertoire du **fork** de votre binome
* Cr√©ez une feature branch `add-tests`.

== Ajout des Outils de Tests Automati√©s au Projet (1/3)

L'execution de tests necessite un outillage non ajout√© au projet

* Framework d'ecriture et d'execution de tests: `JUnit`
* Librarie de cr√©ation de mocks: `Mockito`
* Plugin maven de lancement de tests: `surefire`

== Ajout des Outils de Tests Automati√©s au Projet (2/3)

Ajoutez le bloc suivant au `pom.xml`

[source,xml]
----
<dependencies>
  <!-- ...  -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
  </dependency>
  <!-- ...  -->
</dependencies>
----

== Ajout des Outils de Tests Automati√©s au Projet (3/3)

* Ex√©cutez les tests unitaires avec la commande `mvn test`
** Spoiler : `No tests to run...`

image::https://media.giphy.com/media/5x89XRx3sBZFC/giphy.gif[]

== Exercice : Corriger un Bug (1/11)

* La classe `ListMenuService` semble √™tre bugg√©e...
** Tous les noms des menus sont *TODO* üò±
* Quand on regarde l'impl√©mentation, on se rends compte que le probl√®me provient de la methode statique `fromModel` de la classe `MenuDTO`
* M√™me si la correction est ais√©e, on va d'abord √©crire un test unitaire qui valide le comportement du service.
* Notre SUT: `ListMenuService` + `MenuDTO`

== Exercice : Corriger un Bug (2/11)

Mise en place du test

[source,java]
--
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

public class ListMenuServiceTests {

  private ListMenuService subject;

  @BeforeEach
  public void init() {
    subject = new ListMenuService(null);
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsKnownMenus() {
     List<MenuDto> got = subject.listMenus();
  }
}
--

== Exercice : Corriger un Bug (3/11)

* Super on √† un test, il ne reste plus qu'√† le lancer avec `mvn run` üéâ
* Spoiler `java.lang.NullPointerException`

image::https://media.giphy.com/media/ceHKRKMR6Ojao/giphy.gif[]

== Exercice : Corriger un Bug (4/11)

* Le `ListMenuService` √† besoin d'un `MenuRepository` pour fonctionner.
* Cependant :
** On ne veut pas valider le comportement du `MenuRepository`, il est en dehors de notre SUT.
** Pire, on ne veut pas se connecter √† une base de donn√©e pendant un test unitaire.

== Exercice : Corriger un Bug (5/11)

Solution : On fournit une "fausse impl√©mentation" au service, un mock.

[source,java]
----
// src/test/java/com/cicdlectures/menuserver/service/ListMenuServiceTests.java

private MenuRepository menuRepository;

private UserService subject;

@BeforeEach
public void init() {
  this.repository = mock(MenuRepository.class);
  this.subject = new ListMenuService(this.repository);
}
----

== Exercice : Corriger un Bug (6/11)

Ce "mock" peut √™tre pilot√© dans les tests!

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // Quand le repository re√ßoit l'appel findAll
  // Alors il retourne la valeur null.
  when(repository.findAll()).thenReturn(null);
}
----

== Exercice : Corriger un Bug (7/11)

* Super on √† un test, il ne reste plus qu'√† le lancer avec `mvn run` üéâ
* Spoiler: ‚úÖ

image::https://media.giphy.com/media/a0h7sAqON67nO/giphy.gif[]

== !

Sauf qu'on avait pas un bug √† corriger au fait?

== Exercice : Corriger un Bug (8/11)

Objectif: V√©rifier que les valeurs retourn√©es par le `ListMenuServive` sont coh√©rentes
avec les donn√©es en base, pour cela il nous faut:

* Pr√©parer un jeu de donn√©es de test et configurer le mock du repository pour qu'il le retourne
* Appeler notre service
* Comparer le r√©sultat obtenu du service avec des valeurs attendues.

== Exercice : Corriger un Bug (9/11)

[source,java]
----
@Test
@DisplayName("lists all known menus")
public void listsKnownMenus() {
  // Definit une liste de menus avec un menus.
  Iterable<Menu> existingMenus = Arrays.asList(
    new Menu(
      Long.valueOf(1),
      "Christmas menu",
      new HashSet<>(
        Arrays.asList(
          new Dish(Long.valueOf(1), "Turkey", null),
          new Dish(Long.valueOf(2), "Pecan Pie", null)
        )
      )
    ),
  )

  // On configure le menuRepository pour qu'il retourne notre liste de menus.
  when(menuRepository.findAll()).thenReturn(existingMenus);

  // On appelle notre sujet
  List<MenuDto> gotMenus = subject.listMenus();

  // On definit wantMenus, les r√©sultats attendus
  Iterable<MenuDto> wantMenus = Arrays.asList(
      new MenuDto(
        Long.valueOf(1),
        "Christmas menu",
        new HashSet<>(
          Arrays.asList(
            new DishDto(Long.valueOf(1), "Turkey"),
            new DishDto(Long.valueOf(2), "Pecan Pie")
          )
        )
      )
    );

    // On compare la valeur obtenue avec la valeur attendue.
    assertEquals(wantMenus, gotMenus);
}
----

== Exercice : Corriger un Bug (10/11)

* Super on √† un test (qui teste!), il ne reste plus qu'√† le lancer avec `mvn run` üéâ
* Spoiler:

[source,bash]
----
[ERROR] Failures:
[ERROR]   ListMenuServiceTests.listsKnownMenus:66
expected:
  <[MenuDto(id=1, name=Christmas menu, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
but was:
  <[MenuDto(id=1, name=TODO LOL, dishes=[DishDto(id=2, name=Pecan Pie), DishDto(id=1, name=Turkey)])]>
----

image::https://media.giphy.com/media/FG14fnY17opr2/giphy.gif[]

== Exercice : Corriger un Bug (11/11)

* Il ne reste plus qu'a faire la correction et le tour est jou√©!

image::https://media.giphy.com/media/111ebonMs90YLu/giphy.gif[width="800"]

== Test Unitaire : Quelques R√®gles

* Un test unitaire teste un et un seul comportement
* Faites attention a ce que votre test teste vraiment quelque chose!
** Avec les mocks, c'est facile de se faire pi√©ger.
* Essayez, dans la mesure du possible, d'√©crire vos tests (qui √©chouent) avant d'√©crire votre code.
* Il n'y a pas de d√©finition ferme du SUT
** Attention √† garder une taille raisonable (quelques classes).
* Privil√©giez les tests de m√©thodes publiques.

== Test Unitaire : Pro / Cons

* ‚úÖ Super rapides (<1s) et l√©gers a executer
* ‚úÖ Pousse √† avoir un bon design de code
* ‚úÖ Efficaces pour tester des cas limites
* ‚ùå Peu r√©alistes

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants ind√©pendament ne prouve pas que le syst√®me fonctionne une fois int√©gr√©!

== Solution: Tests d'int√©gration

* Test validant qu‚Äôun assemblage d‚Äôunit√©s se comportent comme pr√©vu.
* Par exemple avec menu server:
**  Prouve que GET /menus retourne la liste des menus enregistr√©s en base
**  Prouve que POST /menus enregistre un nouveau menu en base avec ses plats.

== D√©finition du SUT

image::architecture.png[]

== Configuration de Maven

== Miste en Place d'un Test d'Int√©gration

[source,java]
----
// Lance l'application sur un port al√©atoire.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// Indique de relancer l'application √† chaque test.
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class MenuControllerIT {

  @LocalServerPort
  private int port;

  private URL getServerURL() throws Exception {
    return new URL("http://localhost:" + port + "/menus");
  }

  @Test
  @DisplayName("lists all known menus")
  public void listsAllMenus() throws Exception {
  }
}
----
