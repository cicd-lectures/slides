[{invert}]
= Comment fonctionnent les Internets?

image::https://media1.tenor.com/m/X6lbLfskG4MAAAAC/internet-web.gif[caption="Internet",width=512]

== !

üßê Que se passe-t-il quand je tape google.com dans mon navigateur et que j'appuie sur entr√©e?

== !

1. üìñ Resolution DNS
2. üõú Connection TCP
3. üîí Handshake TLS
4. ‚û°Ô∏è  Envoi d'une requ√™te HTTP au Serveur
5. ‚¨ÖÔ∏è R√©ception d'une reponse et d√©codage du contenu
6. üé® Rendu de la page

== Zoom sur HTTP

* Hypertext Transfer Protocol
* D√©finit un format de requ√™te/r√©ponse dans le mod√®le client / serveur
** Le client demande une ressource √† un serveur via une requ√™te HTTP, serveur lui r√©ponds une r√©ponse avec un contenu.
* Plusieurs versions en activit√© HTTP/1.1, HTTP/2, HTTP/3, mais la s√©mantique reste la m√™me

== Anatomie d'une requ√™te HTTP

Une requ√™te est compos√©e des champs suivant:

* *M√©thode*: Indique une action d√©sir√©e (`GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`...)
* *Hote*: indique un domaine dans lequel r√©cup√©rer les resources (`github.com`)
* *Chemin* (path): indique une ressource √† obtenir au serveur (`/assets/file.js`)
* *Param√®tres de requ√™te* (query parameters): param√®tres additionnels de requ√™te appos√©s au path (`/pages/node?utm_source=facebook`)
* *Ent√™tes* (headers): Couple cl√© -> multiples valeurs indiquant des m√©ta information sur la requ√™te (`Accepted-Content`, `User-Agent`,`Accept`, `Referrer`, `Authorization`, `Cookies`)
* *Corps* (body): Optionnel, contenu encod√© √† envoyer au serveur, par exemple une soumission de formulaires.

== Anatomie d'une r√©ponse HTTP

Une r√©ponse est compos√©e des champs suivant:

* link:https://http.cat[D'un status code] üê±
** 200 OK, 404 Not Found, 301 Moved Permanently etc..
* *Ent√™tes* (headers): Couple cl√© -> multiples valeurs indiquant des m√©ta information sur la r√©ponse (`Content-Length`, `Content-Encoding`,`Content-Type` ...)
* *Un corps de r√©ponse* √† lire et √† d√©coder

== Comment parler HTTP depuis le terminal?

* On propose d'utiliser link:https://curl.se/[cURL]
* Outil pour transf√©rer des donn√©es dans diff√©rents protocoles
** Le couteau suisse des internets!

== üéì Exercice: Premi√®re Requ√™te en utilisant cURL

* Que signifie cette ligne de commande?
** Indice: `man curl`
* Que pouvez vous dire du r√©sultat affich√©?

[source,bash]
----
curl --verbose --location --output /dev/null voi.com
----

== ‚úÖ Solution: Premi√®re Requ√™te en utilisant cURL (1/4)

* C'est verbeux üôÉ, mais on l'a demand√© avec `--verbose`. cURL va logger tous les √©changes effectu√©s avec le serveur
* `--location` indique √† cURL de suivre les redirections
* `--output` indique √† cURL d'√©crire le contenu dans r√©pondu `/dev/null` au lieu de l'afficher sur la sortie standard

== ‚úÖ Solution: Premi√®re Requ√™te en utilisant cURL (2/4)

Regardons d'un peut plus pr√®s les logs:

[source,bash]
----
# On se connecte a une IPv6... probablement celle de voi.com?
* Trying [2606:4700:20::681a:3d6]:80...
* Connected to voi.com (2606:4700:20::681a:3d6) port 80

# cURL formule la requ√™te demand√©e sur HTTP.
> GET / HTTP/1.1
> Host: voi.com
> User-Agent: curl/8.4.0
> Accept: */*
>
# Le serveur nous r√©ponds une 301 !? voi.com √† boug√©?
< HTTP/1.1 301 Moved Permanently
# [...]
# Aha! Le serveur nous redirige vers le m√™me site, mais en HTTPS sur le port 443.
< Location: https://voi.com:443/
----

== ‚úÖ Solution: Premi√®re Requ√™te en utilisant cURL (3/4)

[source,bash]
----
# Comme indiqu√©: on se reconnecte a voi.com sur le port 443!
* Clear auth, redirects to port from 80 to 443
* Issue another request to this URL: 'https://voi.com:443/'
*   Trying [2606:4700:20::681a:3d6]:443...
* Connected to voi.com (2606:4700:20::681a:3d6) port 443

# On se connecte en HTTPS, du coup il va falloir √©tablir une session TLS
# Ensuite cURL et le serveur se mettent d'accord et √©tablissent la connexion s√©curis√©e.
* (304) (OUT), TLS handshake, Client hello (1):
# [...]
# On est connect√©s de fa√ßon s√©curis√©e au serveur!
* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* Server certificate:
# [...] Le certificat du serveur est valide!
*  SSL certificate verify ok.
# [...] On refait notre requ√™te une fois connect√©s!
> GET / HTTP/2
> Host: voi.com
> User-Agent: curl/8.4.0
> Accept: */*
>
# Victoire le serveur nous r√©ponds!
< HTTP/2 200
# Du HTML!
< content-type: text/html; charset=utf-8
# et 22kb de donn√©es!
{ [21877 bytes data]
----

== ‚úÖ Solution: Premi√®re Requ√™te en utilisant cURL (4/4)

* Ce qu'il viens de se passer est ce que l'on appelle une `HTTPS` upgrade
* Le serveur force le client a se connecter de fa√ßon s√©curis√©e!
* Pourquoi?
** TLS prouve que le client parle bien au bon serveur!
** TLS chiffre les communications sur le r√©seau, on peut faire transiter des donn√©es sans(trop) se soucier d'√™tre espionn√©s üïµÔ∏è

== !

* Maintenant essayez d'enlever l'option `--location`, que se passe-t-il?
* Maintenant essayez d'enlever l'option `--output /dev/null`, que se passe-t-il?

== Autres Options Utiles de cURL

* Contr√¥le de la m√©thode de la requ√™te: `--request POST`, `--request DELETE`
* Ajouter un header a la requ√™te: `--header "Content-Type: application/json"`
* Envoyer un body dans la requ√™te:
** Directement depuis la ligne de commande `--data '{"some":"json"}`
** En lisant un ficher `--data '@some/local/file'`

Essayez donc sur voi.com!

== üéì Exercice: Afficher du JSON de Fa√ßon Lisible

* Qu'affiche le r√©sultat de la commande suivante?
* Comment le rendre plus lisible?
** Indice: il faut utilser un `|` (pipe) et la commande `jq`

[source,bash]
----
curl https://swapi.dev/api/planets/1
----

== ‚úÖ Solution: Afficher du JSON de Fa√ßon Lisible

[source,bash]
----
curl https://swapi.dev/api/planets/1 | jq .
----

* Bonus: jq permets de s√©lectionner un attribut JSON.

[source,bash]
----
curl https://swapi.dev/api/planets/1 | jq .residents
----

== Checkpoint üéØ

* Internet repose sur une collection de protocole (DNS, TCP, TLS, HTTP)
* HTTP permets de formuler une requ√™te √† un serveur et une r√©ponse
* `cURL` est un outil tr√®s complet pour parler HTTP depuis un terminal!
