[{invert}]
= La Gestion des DÃ©pendances

ğŸ‡ºğŸ‡¸ Dependency Management

== !

Dans ce chapitre on ne parle que de dÃ©pendances du code

== Pourquoi rÃ©utiliser du code?

* ğŸ§± L'informatique moderne est un assemblage de briques logicielles
* âš™ï¸ ... chacune des briques Ã©tant infiniment complexe
** Ex: TLS, PostgresSQL, Linux, Firefox...
* ğŸ¤” Il est difficilement envisageable de dÃ©marrer un projet sans rÃ©utiliser des briques logicielles.
* ğŸ§˜ Cela permet de *concentrer son effort de dÃ©velopement sur ce qui apporte vraiment de la valeur*.
** â¡ï¸ Dans notre cas, notre mÃ©tier est la gestion de vÃ©hicules, pas l'implÃ©mentation d'une pile rÃ©seau et d'un serveur HTTP.

== âš ï¸ Ajouter une dÃ©pendance n'est pas un acte anodin âš ï¸ 

* Si votre dÃ©pendance ne fonctionne plus ou est compromise, votre app sera impactÃ©e
* Attention Ã  ne pas rajouter une dÃ©pendance trop grosse pour n'utiliser qu'une petite fonctionalitÃ©!
* Attention aux dÃ©pendances de vos dÃ©pendances ğŸ˜±
* Quelques rÃ¨gles d'usage:
** VÃ©rifier que votre dÃ©pendance est activement maintenue? (date du dernier commit, existence d'une communautÃ© autour)
** ğŸ‘€ le code. Est-ce que vous le comprenez? Est-ce que vous pourriez le dÃ©bugger ou le faire vous mÃªme?

== DÃ©pendre de librairies externes pose une quantitÃ© de problÃ¨mes!

* Comment rÃ©cupÃ©rer tout le code dont on Ã  besoin?
* Comment le maintenir Ã  jour?
* Comment s'assurer qu'il n'a pas Ã©tÃ© modifiÃ©?
* Comment garantir la reproductibilitÃ© de nos builds?

== !

image::dependency-graph.png[caption="Dependency Graph",width=1024]

Mais le pire, c'est que c'est un problÃ¨me rÃ©cursif! Nos dÃ©pendances ont aussi des dÃ©pendances!

== !

image::npm-dependency-graph.webp[caption="Dependency Graph",width=1024]

== !

image::https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHRxYmd1bGtjcTNyZmh1dXoxaWZsd3g5NWdiem40OW96YzFlbm12YyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/HUkOv6BNWc1HO/giphy.gif[caption="Panic",width=1024]

== Un peu de terminologie

* Une *dÃ©pendance* est une librairie de code externe qui fournit une fonctionnalitÃ©.
* On distingue deux types de dÃ©pendances:
** Une *dÃ©pendances directe*: rÃ©fÃ©rencÃ©e directement par notre application
** Une *dÃ©pendances transitive*: rÃ©fÃ©rencÃ©e par une des librairies dont l'application dÃ©pends

== Comment rÃ©soudre le problÃ¨me?

* On introduit un outil de gestion de dÃ©pendances
** Permets au dÃ©veloppeur de dÃ©finir une liste de dÃ©pendences en fixant ou en plaÃ§ant une contrainte de version (ex <= 4.3.0)
** Construit un graph de dÃ©pendences de faÃ§on et le rÃ©soud a obtenir une liste de dÃ©pendances Ã  tÃ©lecharger de faÃ§on dÃ©terministe
** TÃ©lecharge les dÃ©pendances sur la machine a distance et les mets Ã  disposition de l'application.

== Comment cela fonctionne avec go?

image:gopher-tired.png[caption="Gopher Tired",width=256]

link:https://www.deviantart.com/quasilyte/art/Tired-gopher-783302842[source]

== Quelques rappels sur go

* Tout symbole go est dÃ©fini dans un package
* Un package est identifiÃ© par une URL unique
** (ex: `github.com/prometheus/client_golang`)
* Un package peut importer un ou plusieurs autres packages pour utiliser ses symboles.

== Provenances des packages

* La librairie standard
** âœ… La version est controllÃ©e par la version de go utilisÃ©e pour compiler
* La base de code du projet
** âœ… ControllÃ©e par notre VCS
* D'une ou plusieurs librairies externes
** âŒ Pas de solutions pour l'instant

== Bonjour go modules

* Go introduit la notion de *modules*: une collection de packages qui sont livrÃ©s, versionnÃ©s et distribuÃ©s enssemble
* Un module est identifiÃ© par un *module path* dÃ©clarÃ© dans un fichier appelÃ© `go.mod`
* Le fichier `go.mod` est situÃ© a la racine du module et englobe tous les packages dÃ©finis en dessous de ce fichier

== Le module github.com/prometheus/client_golang

[source,bash]
----
include::../code-samples/go/module_tree[]
----

== Que dÃ©clare le fichier go.mod

* Le module path: l'identifiant unique du module
* La version minimum de go nÃ©cessaire pour utiliser ce module
* Les modules dont dÃ©pends le module courant
** âš ï¸  La version *minimale* Ã  utiliser est indiquÃ©e explicitement

== Un exemple de go.mod

[source,go]
----
include::../code-samples/go/example.go.mod[]
----

== ğŸ“ Exercice: Ajout de la gestion de dÃ©pendances (1/3)

* On initialise un nouveau module

[source,bash]
----
go mod init github.com/${VOTRE_UTILISATEUR_GITHUB}/vehicle-server
----

* On ajoute les dÃ©pendances au projet

[source,bash]
----
go mod tidy
----

* âŒ Cela ne fonctionne pas, que se passe t'il?

== ğŸ“ Exercice: Ajout de la gestion de dÃ©pendances (2/3)

* Les fichiers go du projet importent encore des packages issus du module original!
** `github.com/cicd-lectures/vehicle-server`
* Il faut les renommer, pour cela utilisez la commande suivante!

[source,bash]
----
find . -type f -name '*.go' -exec sed -i -e 's,github.com/cicd-lectures,github.com/${VOTRE_UTILISATEUR_GITHUB},g' {} \;
----

* Pour vÃ©rifier que cette (horrible) commande a fonctionnÃ© on peut utiliser `git diff`
* Une fois cela fait on peut relancer

[source,bash]
----
go mod tidy
----

== ğŸ“ Exercice: Ajout de la gestion de dÃ©pendances (3/3)

* Affichez maintenant le graph de dÃ©pendances du projet

[source,bash]
----
go mod graph

# Regarder uniquement les dÃ©pendances de pgx
go mod graph | grep pgx
----

* La partie droite indique le module parent, la partie gauche les modules dont dÃ©pend le module parent.
* âš ï¸ C'est verbeux, vous pouvez utiliser `| grep` pour filtrer le resultat

* Et pour finir, on oublie pas de crÃ©er un commit :)

== RÃ©solution Reproductibilible: l'algorithme MVS (1/2)

* *MVS*: Minimum Version Selection
* Go cherche Ã  utiliser la *version minimale* d'une dÃ©pendance
* L'algorithme *est dÃ©terministe*:
** Il ne change pas si une nouvelle version d'un module est mise Ã  disposition.
** Pas besoin de `lockfile` (comme sur npm, bundler, pip etc...)

== RÃ©solution Reproductibilite: l'algorithme MVS (2/2)

image:buildlist.svg[caption="BuildGraph",width=700]


== Controller le Contenu TÃ©lÃ©chargÃ©

* `go` lit le fichier `go.mod` du module Ã  compiler et dÃ©termine la liste des modules Ã  tÃ©lÃ©charger
* Il les tÃ©lÃ©charge soit depuis:
** Un `module proxy`
** Depuis un dÃ©pÃ´t de code directement (via git, mercurial etc...)
* `go` calcule ensuite une somme de contrÃ´le (checksum) des fichiers tÃ©lÃ©chargÃ©s et la compare avec un rÃ©fÃ©renciel Ã©tabli lors du premier tÃ©lechargement: le fichier `go.sum`.
** â¡ï¸  Cela garantit que les dÃ©pendances tÃ©lÃ©chargÃ©es n'ont pas Ã©tÃ© altÃ©rÃ©es entre deux tÃ©lechargements.

== Quelques Commandes Utiles:

* `go get <modulepath>@version`: Ajoute un module Ã  la liste de dÃ©pendances
* `go mod tidy`: Nettoie le fichier `go.mod` en rÃ©cupÃ©rant tout les modules importÃ©s par l'application et en s'assurant que le fichier `go.sum` est Ã  jour.
* `go get -u ./...` Update tous les modules dÃ©pendants
* `go get -u <modulepath>` Mets Ã  jour un module
* `go mod why` indique le chemin de dÃ©pendance entre le package courant et un package (ou un module avec le flag `-m`)
* `go list -m all` affiche la liste des modules Ã  compiler

== ğŸ“ Exercice: Compiler le serveur

A vous de jouer, il nous faut maintenant compiler et lancer notre serveur!

== âœ… Solution: Compiler le serveur

[source,bash]
----
# On dÃ©marre le serveur de base de donnÃ©es
make dev_db
# On compile le serveur
make all
# On lance notre serveur
./dist/server
----

== Checkpoint ğŸ¯

* La gestion de dÃ©pendances est une question importante et complexe
* Une bonne comprÃ©hension de son systÃ¨me de gestion de dÃ©pendances est nÃ©cessaire pour garantir la reproductibilitÃ© de nos builds
* go fournit une suite d'outils intÃ©grÃ©es qui simplifie la gestion des dÃ©pendances externes
* ğŸ‰ On est maintenant en mesure de compiler notre projet! ğŸ‰
