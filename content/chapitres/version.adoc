[{invert}]
= Versions

== Pourquoi faire des versions ?

* Un changement visible d'un logiciel peut n√©cessiter une adaptation de ses utilisateurs
* Un humain √ßa s'adapte, mais un logiciel il faut l'adapter!
* Cela permet de contr√¥ler le probl√®me de la compatibilit√© entre deux logiciels.

== Une petite histoire

Le logiciel que vous d√©veloppez utilise des donn√©es d'une API d'un site de vente.

[source,json]
--
// Corps de la r√©ponse d'une requ√™te GET https://supersite.com/api/item
[
  {
    "identifier": 1343,
    // ...
  }
]
--

Voici comment est repr√©sent√© un item vendu dans votre code.

[source,java]
--
public class Item {
  // Identifiant de l'item repr√©sent√© sous forme d'entier.
  private int identifier;
  // ...
}
--

[%notitle]
== Une petite histoire

Le site d√©cide tout d'un coup de changer le format de l'identifiant de son objet en cha√Æne de caract√®res.

[source,json]
--
// Corps de la r√©ponse d'une requ√™te GET https://supersite.com/api/item
[
  {
    "identifier": "lolilol3843",
    // ...
  }
]
--

Que se passe t'il du c√¥t√© de votre application ?

[%notitle]
== !

`com.fasterxml.jackson.databind.JsonMappingException`


image::explosion.gif[width="800"]

== Qu'est s'est il pass√© ?

* Votre application ne s'attendait pas √† un identifiant sous forme de cha√Æne de caract√®res !
* Le fournisseur de l'API √† "chang√© le contrat" de son API d'une fa√ßon non r√©trocompatible avec votre l'existant.
** Cela s'appelle un üá¨üáß *Breaking Change*

== Comment √©viter cela ?

* Laisser aux utilisateurs une marge de manoeuvre pour "accepter" votre changement.
** Donner une garantie de maintien des contrats existants.
** Informer vos utilisateurs d'un changement non r√©trocompatible.
** Anticiper les changements non r√©trocompatibles √† l'aide de strat√©gies (d√©pr√©ciation).

== Bonjour versions !

* Une version cristallise un contrat respect√© par votre application.
* C'est un jalon dans l'histoire de votre logiciel

[.notes]
--
Valide d'un point de vue fonctionnel et aussi technique
--

== Quoi versionner ?

Le probl√®me de la compatibilit√© existe d√®s qu'une d√©pendance entre deux bouts de code existe.

* Une API
* Une librairie
* Un langage de programmation
* Le noyau linux

== Version s√©mantique

La norme est l'utilisation du format vX.Y.Z (Majeur.Mineur.Patch)

image:semver.png[width="600"]

(source link:https://medium.com/better-programming/why-versioning-is-important-and-how-to-do-it-686ce13b854f[betterprograming])

[%notitle]
== !

Un changement **ne changeant pas le p√©rim√®tre fonctionnel** incr√©mente le num√©ro de version **patch**.

[.notes]
--
Example:

Un bugfix
--

[%notitle]
== !

Un changement changeant le p√©rim√®tre fonctionnel de fa√ßon **r√©trocompatible** incr√©mente le num√©ro de version **mineure**.

[.notes]
--

Example:

Ajout d'une fonctionnalit√© suppl√©mentaire (nouvelle route dans une API).
--

[%notitle]
== !


Un changement changeant le p√©rim√®tre fonctionnel de fa√ßon **non r√©trocompatible** incr√©mente le num√©ro de version **majeure**.

[.notes]
--

Example:

Retrait d'une fonctionnalit√© (retrait d'une route dans une API).
--

== En r√©sum√©

* Changer de version mineure ne devrait avoir aucun d'impact sur votre code.
* Changer de version majeure peut n√©cessiter des adaptations.

==  Concr√®tement avec une API

* Offrir a l'utilisateur un moyen d'indiquer la version de l'API a laquelle il souhaite parler
** Via un pr√©fixe dans le chemin de la requ√™te:
*** `https://monsupersite.com/api/v2.3/item`

** Via un en-t√™te HTTP:
*** `Accept-version: v2.3`

== Version VS Git

* Un identifiant de commit est de granularit√© trop faible pour un l'utilisateur externe.
* Utilisation de *tags* git pour d√©finir des versions.
* Un *tag* git est une r√©f√©rence sur un commit.

== Exercice: Cr√©ez et "taggez" la version v0.0.1 de votre menu-server

[source,bash]
----

# Cr√©er un tag.
git tag -a v1.4.3 -m "Release version v1.4.3"


# Publier un tag sur le remote origin.
git push origin v1.4.3
----
