[{invert}]
= Versions

== Pourquoi faire des versions ?

* Un changement visible d'un logiciel peut nÃ©cessiter une adaptation de ses utilisateurs
* Un humain Ã§a s'adapte, mais un logiciel il faut l'adapter!
* Cela permet de contrÃ´ler le problÃ¨me de la compatibilitÃ© entre deux logiciels.

== Une petite histoire

Voi dÃ©veloppe un client mobile qui utilise l'API exposÃ©e par le vehicle-server. Imaginez que vous changiez le contenu de la rÃ©ponse de `list vehicles`

[source,json]
--
{
  "vehicles": [
      {
        "id": 12,
        "longitude": 34.33,
        "latitude": 43.5343,
-       "shortcode": "abef"
+       "short_code": "abef"
      }
  ],
}
--

Que se passe t'il du cÃ´tÃ© de votre application ?

[%notitle]
== !

image::explosion.gif[width="800"]

ğŸ’¥ Plus personne ne peut dÃ©vÃ©rouiller de vÃ©hicle! ğŸ’¥ 

== Qu'est s'est il passÃ© ?

* Le client mobile ne s'attendait pas Ã  ce que le ShortCode du vehicule soit retournÃ© sous l'attribut `short_code`!
* Vous avez "changÃ© le contrat" de votre API d'une faÃ§on non rÃ©trocompatible avec votre l'existant.
** Cela s'appelle un ğŸ‡¬ğŸ‡§ *Breaking Change*

== Comment Ã©viter cela ?

* Laisser aux utilisateurs une marge de manoeuvre pour "accepter" votre changement.
** Donner une garantie de maintien des contrats existants.
** Informer vos utilisateurs d'un changement non rÃ©trocompatible.
** Anticiper les changements non rÃ©trocompatibles Ã  l'aide de stratÃ©gies (dÃ©prÃ©ciation).

== Bonjour versions !

* Une version cristallise un contrat respectÃ© par votre application.
* C'est un jalon dans l'histoire de votre logiciel

[.notes]
--
Valide d'un point de vue fonctionnel et aussi technique
--

== Quoi versionner ?

Le problÃ¨me de la compatibilitÃ© existe dÃ¨s qu'une dÃ©pendance entre deux bouts de code existe.

* Une API
* Une librairie
* Un langage de programmation
* Le noyau linux

== Version sÃ©mantique

La norme est l'utilisation du format vX.Y.Z (Majeur.Mineur.Patch)

image:semver.png[width="600"]

(source link:https://medium.com/better-programming/why-versioning-is-important-and-how-to-do-it-686ce13b854f[betterprograming])

[%notitle]
== !

Un changement **ne changeant pas le pÃ©rimÃ¨tre fonctionnel** incrÃ©mente le numÃ©ro de version **patch**.

[.notes]
--
Example:

Un bugfix
--

[%notitle]
== !

Un changement changeant le pÃ©rimÃ¨tre fonctionnel de faÃ§on **rÃ©trocompatible** incrÃ©mente le numÃ©ro de version **mineure**.

[.notes]
--

Example:

Ajout d'une fonctionnalitÃ© supplÃ©mentaire (nouvelle route dans une API).
--

[%notitle]
== !


Un changement changeant le pÃ©rimÃ¨tre fonctionnel de faÃ§on **non rÃ©trocompatible** incrÃ©mente le numÃ©ro de version **majeure**.

[.notes]
--

Example:

Retrait d'une fonctionnalitÃ© (retrait d'une route dans une API).
--

== En rÃ©sumÃ©

* Changer de version mineure ne devrait avoir aucun d'impact sur votre code.
* Changer de version majeure peut nÃ©cessiter des adaptations.

==  ConcrÃ¨tement avec une API

* Offrir a l'utilisateur un moyen d'indiquer la version de l'API a laquelle il souhaite parler
** Via un prÃ©fixe dans le chemin de la requÃªte:
*** `https://vehicles.voi.com/v2.3/vehicles`

** Via un en-tÃªte HTTP:
*** `Accept-version: v2.3`

== Version VS Git

* Un identifiant de commit est de granularitÃ© trop faible pour un l'utilisateur externe.
* Utilisation de *tags* git pour dÃ©finir des versions.
* Un *tag* git est une rÃ©fÃ©rence sur un commit.

[{invert}]
== !

Nous sommes prÃªts, il est grand temps de faire la release de notre v1.0.

[{invert}]
== !

...mais c'est quoi notre production dÃ©jÃ ?

== ğŸï¸ Notre production sera...

* Une image Docker de l'application...
* ... visible sur le link:https://hub.docker.com/[Docker Hub]...
* ... avec un (Docker) tag pour chaque version

== ğŸ“ ğŸ³ Docker Hub

* Si vous n'avez pas dÃ©jÃ  un compte sur le link:https://hub.docker.com/[Docker Hub], crÃ©ez-en un maintenant (nÃ©cessite une validation)
* Une fois authentifiÃ©s, naviguez dans votre compte (en haut Ã  droite, "My Account")
* Allez dans la section "Security" et crÃ©ez un nouvel "Access Token"
** Permissions: "Read & Write" (pas besoin de "Delete")
** âš ï¸ Conservez ce token dans un endroit sÃ»r (ne PAS partagez Ã  d'autres)

[.small]
ğŸ’¡ Activer le 2FA est une bonne idÃ©e Ã©galement


== ğŸ“ "Taguez" et dÃ©ployez la version 1.0.0

* Depuis GitPod, crÃ©ez un tag git local `1.0.0`
** ğŸ’¡ `git tag 1.0.0 -a -m "PremiÃ¨re release 1.0.0, mode manuel"`

* Fabriquez l'image Docker avec le tag (Docker) 1.0.0
** ğŸ’¡ `make package` ?

* DÃ©ployez l'image sur le DockerHub
** ğŸ’¡ `docker login`, `docker image push`

* Publier le tag sur votre "remote" `origin``.
** ğŸ’¡ `git push origin 1.0.0`

* ğŸ’¡ Peut Ãªtre faire un `make release` qui englobe git tag et docker push ?

== âœ… "Taguez" et dÃ©ployez la version 1.0.0

[source,Makefile]
----
.PHONY all
all: clean dist unit_test integration_test build package release

.PHONY: release
release:
  git tag $(TAG) -m "$(TAG_MESSAGE)"
  git push $(TAG)
  docker push $(IMAGE):$(TAG)
----

[source,bash]
----
docker login --username=<VOTRE USERNAME>

make all TAG="1.0.0" "TAG_MESSAGE="PremiÃ¨re Release, Version Manuelle"
----

VÃ©rifiez Git et DockerHub aprÃ¨s Ã§a!

== Checkpoint ğŸ¯

* La notion de "version" est un outil de communication aux consommateurs de nos produits logiciels

* Le "semantic versioning" est une des faÃ§on les plus usitÃ©es pour gÃ©rer les politiques de version

* Nous avons dÃ©ployÃ© manuellement notre premiÃ¨re image Docker, avec synchronisation code source <-> image Docker

=> ğŸ¤” C'Ã©tait trÃ¨s manuel. Et si on regardait Ã  automatiser tout Ã§a ?
